<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>电子基础的旅途</title>
      <link href="/water.github.io/2024/10/31/%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80%E7%9A%84%E6%97%85%E9%80%94/"/>
      <url>/water.github.io/2024/10/31/%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80%E7%9A%84%E6%97%85%E9%80%94/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的摄影之旅</title>
      <link href="/water.github.io/2024/10/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%91%84%E5%BD%B1%E4%B9%8B%E6%97%85/"/>
      <url>/water.github.io/2024/10/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%91%84%E5%BD%B1%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微积分的旅程</title>
      <link href="/water.github.io/2024/10/17/%E5%BE%AE%E7%A7%AF%E5%88%86%E7%9A%84%E6%97%85%E7%A8%8B/"/>
      <url>/water.github.io/2024/10/17/%E5%BE%AE%E7%A7%AF%E5%88%86%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="微积分的旅程"><a href="#微积分的旅程" class="headerlink" title="*微积分的旅程"></a>*微积分的旅程</h1><h2 id="第一站-–-微积分的本质"><a href="#第一站-–-微积分的本质" class="headerlink" title="第一站 – 微积分的本质"></a>第一站 – 微积分的本质</h2><h2 id="第二站-–-微积分的深入理解"><a href="#第二站-–-微积分的深入理解" class="headerlink" title="第二站 – 微积分的深入理解"></a>第二站 – 微积分的深入理解</h2><h2 id="第三站-–-微积分的进阶（数学分析）"><a href="#第三站-–-微积分的进阶（数学分析）" class="headerlink" title="第三站 – 微积分的进阶（数学分析）"></a>第三站 – 微积分的进阶（数学分析）</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 纯数学Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析的旅程</title>
      <link href="/water.github.io/2024/10/14/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%9A%84%E6%97%85%E7%A8%8B/"/>
      <url>/water.github.io/2024/10/14/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 应用数学Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学的旅程</title>
      <link href="/water.github.io/2024/10/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%9A%84%E6%97%85%E7%A8%8B/"/>
      <url>/water.github.io/2024/10/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学的旅程"><a href="#离散数学的旅程" class="headerlink" title="*离散数学的旅程"></a>*离散数学的旅程</h1><p>参考书籍：离散数学第六版（屈婉玲）</p><p>第一章</p>]]></content>
      
      
      
        <tags>
            
            <tag> 应用数学Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于学习CSAPP这档事</title>
      <link href="/water.github.io/2024/10/10/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0CSAPP%E8%BF%99%E6%A1%A3%E4%BA%8B/"/>
      <url>/water.github.io/2024/10/10/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0CSAPP%E8%BF%99%E6%A1%A3%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 随笔札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构的旅程</title>
      <link href="/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/"/>
      <url>/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构的旅程"><a href="#数据结构的旅程" class="headerlink" title="*数据结构的旅程"></a>*数据结构的旅程</h1><p>参考课程：CS61B</p><p>参考文档：Qiushao的CS61B笔记以及 CS61B自身文档</p><p>本文档相当于CS61B文档的简略翻译版</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Java与C语言这种面对过程的语言不同，它是面对对象的，我浅显的理解是：面对对象就是将一个完整的工作流程划分为不同对象，而面对过程是将一个完整的工作流程切割为不同小的过程。具体划分形式是创建文件。</p><p>对象交互原则：低耦合，高内聚。人话：低耦合指的是对象之间的依赖关系尽可能少。对象应该尽量独立，使得一个对象的变化不会影响到其他对象。高内聚指的是一个对象内部的各个部分紧密相关，负责的功能相对集中。每个对象应专注于其特定的职责。</p><h3 id="Java-Workflow"><a href="#Java-Workflow" class="headerlink" title="Java Workflow"></a>Java Workflow</h3><p>由于CS61B使用Java来讲解数据结构，所以在学习数据结构前，我们先来熟悉一下Java.</p><p>Taking a program from a <code>.java</code> file into an executable has two main steps in Java: <strong>compilation</strong> and <strong>interpretation</strong>. </p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20115000.png" alt="屏幕截图 2024-10-22 115000"></p><p>在Java中，<strong>编译</strong>和<strong>解释</strong>是两个不同的过程，它们在程序执行中扮演不同的角色：</p><ol><li><strong>编译</strong>：<ul><li>将Java源代码（<code>.java</code>文件）转换成字节码（<code>.class</code>文件）。这个过程由Java编译器（如<code>javac</code>）完成。</li><li>字节码是平台无关的，可以在任何支持Java的环境中运行。</li></ul></li><li><strong>解释</strong>：<ul><li>运行时，Java虚拟机（JVM）将字节码转换为机器码并执行。这个过程是动态的，因此可以根据不同的操作系统和硬件进行调整。</li><li>解释允许Java程序具备跨平台能力，因只需JVM在目标环境中存在。</li></ul></li></ol><p>总结而言，编译是将源代码转换为字节码的过程，而解释是在运行时执行这些字节码的过程。这样结合使得Java具有了可移植性和安全性。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a><strong>Command Line Arguments</strong></h3><p>与C语言相似，java也有之间的main函数，我们也可以看到C语言中熟悉的命令行参数（如下图）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ArgsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们如下图使用命令行参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java ArgsDemo these are command line arguments</span><br><span class="line">these</span><br></pre></td></tr></table></figure><p>上述过程中解释器将这些参数收集起来，并将它们作为字符串数组传递给<code>main</code>方法的参数（<code>String[] args</code>）</p><p>因此，<code>String[] args</code> 是连接用户输入（命令行参数）和程序执行（解释过程）的桥梁。</p><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>Java中也有类似C语言中的数据类型。数据类型分为<strong>primitive types</strong>和 <strong>reference types</strong></p><ul><li>primitive types：<code>byte, short, int, long, float, double, boolean, char.</code> </li><li>reference types: 除此之外，都是引用类型。</li></ul><h4 id="The-Golden-Rule-of-Equals-GRoE"><a href="#The-Golden-Rule-of-Equals-GRoE" class="headerlink" title="The Golden Rule of Equals (GRoE)"></a>The Golden Rule of Equals (GRoE)</h4><p>When you write <code>y = x</code>, you are telling the Java interpreter to copy the bits from x into y. </p><h3 id="Object-Instantiation"><a href="#Object-Instantiation" class="headerlink" title="Object Instantiation"></a><strong>Object Instantiation</strong></h3><p>classes can be instantiated, and instances can hold data。（实例化是面向对象编程的核心，允许你创建和使用类的具体对象，进而实现数据封装和行为定义。）</p><ol><li><strong>定义类</strong>：首先定义一个类，例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实例化对象</strong>：使用<code>new</code>关键字创建对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>访问对象成员</strong>：可以通过对象访问类的属性和方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(myDog.name); <span class="comment">// 输出：Buddy</span></span><br></pre></td></tr></table></figure><p>实例化与没有实例化的区别：</p><p><strong>实例化（创建对象）</strong>：</p><ul><li><p>通过<code>new</code>关键字创建一个类的对象。</p></li><li><p>你可以访问对象的属性和方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">System.out.println(myDog.name); <span class="comment">// 访问实例变量</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><p><strong>没有实例化</strong>：</p><ul><li><p>你仅有类的定义，但没有创建任何对象。</p></li><li><p>不能直接访问类的属性或方法。例如，如果没有实例化，不能使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Dog myDog; <span class="comment">// 只是声明，没有创建对象</span></span><br><span class="line">System.out.println(myDog.name); <span class="comment">// 会报错，因为myDog没有指向任何对象</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>总结而言，实例化是让类成为具体对象的过程，而没有实例化则意味着仅有类的定义，没有实际的对象可以使用。实例化是执行程序中面向对象操作的关键。</p><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>在实例化对象，我们发现有用到<code>new</code>这个关键词，它有什么作用呢？</p><p>课本原文：</p><p>Java first allocates a box for each instance variable of the class, and fills them with a default value. The constructor then usually (but not always) fills every box with some other value.</p><p>大致意思：<code>new</code>分配<code>constructor</code>构造函数所需的内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Walrus someWalrus;</span><br><span class="line">someWalrus = <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br></pre></td></tr></table></figure><p>正如上面所示：我们分配一个足够的空间给海象。注意：<code>someWalrus</code>只是储存分配空间的地址，<code>new Walrus(1000, 8.3)</code>是真正分配空间的地方。就像somWarlus是一张藏宝图，标记宝藏的位置，而后者被埋在一块待发现挖掘的地方。类似于C语言里的指针。</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20135201.png" alt="屏幕截图 2024-10-22 135201"></p><p>它们所存放的内存位置也不同，someWalrus被放在栈内存，<code>new Walrus(100, 8.3)</code>中的实例变量存放在堆内存。</p><p>在这里插一篇看过的博客：<a href="https://blog.csdn.net/qq_43430343/article/details/119709715?ops_request_misc=%7B%22request_id%22:%22196B88EE-44D9-4DE9-A76A-D329F23AE38A%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=196B88EE-44D9-4DE9-A76A-D329F23AE38A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-22-119709715-null-null.142%5Ev100%5Epc_search_result_base6&utm_term=java%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%8Enew%E5%AD%98%E6%94%BE%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">Java对象在内存中实例化_java对象在内存中实例化的过程-CSDN博客</a></p><h3 id="Java-Members"><a href="#Java-Members" class="headerlink" title="Java Members"></a>Java Members</h3><p>Java一个类中有以下两个元素组成：</p><ul><li>变量（属性）</li><li>方法</li></ul><h4 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h4><p>变量分为实例变量与类变量：</p><ol><li><p>实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些变量要被使用，需要经过以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog d;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.weightInPounds = <span class="number">20</span>;</span><br><span class="line">        d.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">binomen</span> <span class="operator">=</span> <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些变量是归属于类的，而不是实例。使用类变量如上述的binomen：<code>Dog.binomen</code>,而不用像实例变量实例化一个对象。</p></li></ol><p>总而言之，类变量是归属于类的，实例变量是归属于对象的。</p><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>方法也分为实例变量与类变量：</p><ol><li><p>实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d2);</span><br></pre></td></tr></table></figure></li><li><p>类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure></li></ol><p>总而言之，类方法是归属于类的，实例方法是归属于对象的。</p><p>从上面的变量与方法的分类，我们可以发现类变量或方法在声明定义之前都会带有static这个关键词， <code>static</code> 是一个<strong>修饰符</strong>，用于指示类变量或类方法属于类本身，而不是特定的对象。使用 <code>static</code> 声明的变量或方法可以通过类名直接访问，而不需要创建类的实例。</p><p>所以，类变量&#x2F;方法还有一个别名–静态变量&#x2F;方法，而实例变量&#x2F;方法则称作非静态变量&#x2F;方法。</p><p>注意：</p><ul><li><p>静态方法不能调用非静态方法</p></li><li><p>非静态方法能调用静态方法</p><p><strong>原因：</strong>静态方法属于类，随着类的加载而加载，在内存中优先于对象创建。非静态方法属于对象，在对象创建时才会加载。由于静态 方法在对象存在之前就已经存在，因此它无法调用非静态方法，因为非静态方法需要依赖于具体的对象实例才能执行‌。</p><p><strong>static的运用</strong>：工具类（我不想调用一些方法时，还要实例化一个对象）</p></li></ul><h3 id="Constructors-in-Java"><a href="#Constructors-in-Java" class="headerlink" title="Constructors in Java"></a><strong>Constructors in Java</strong></h3><p>之前说过，实例变量&#x2F;实例方法会封装数据，那么类实例化又是怎么操作的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> w)</span> &#123;     </span><br><span class="line">        weightInPounds = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类别："><a href="#类别：" class="headerlink" title="类别："></a>类别：</h4><ul><li><strong>无参构造函数（Default Constructor）</strong>：如果你没有显式定义构造函数，Java会为类生成一个默认的无参构造函数。它什么都不做，只是创建对象。</li><li><strong>有参构造函数（Parameterized Constructor）</strong>：通过这种构造函数，我们可以在对象创建时直接传入参数，给实例变量赋值。可以定义多个有参构造函数（重载），以便根据不同的需求灵活地创建对象.(上述的就是一个有参构造函数)。</li></ul><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li><strong>初始化对象</strong>：构造函数确保在对象创建时，所有必要的数据或资源（如实例变量的初始值）已经准备就绪。</li><li><strong>灵活性</strong>：通过构造函数的重载，可以根据不同的场景初始化对象，从而提供更大的灵活性。</li></ul><h4 id="构造函数与实例化的关系："><a href="#构造函数与实例化的关系：" class="headerlink" title="构造函数与实例化的关系："></a>构造函数与实例化的关系：</h4><p><strong>实例化（Instantiation）</strong>：实例化是创建类的对象的过程，使用 <code>new</code> 关键字实现。这个过程中，构造函数被调用，并为对象的实例变量分配内存并初始化。没有构造函数的参与，无法完成对象的完整初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);  <span class="comment">// 实例化并初始化对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="构造函数与封装的关系"><a href="#构造函数与封装的关系" class="headerlink" title="构造函数与封装的关系:"></a>构造函数与封装的关系:</h4><p><strong>封装（Encapsulation）</strong>：封装是面向对象编程中将数据和行为绑定在一起，同时隐藏对象的内部实现细节的原则。通常，类中的属性会被定义为私有（<code>private</code>），从而避免外部直接访问。这时候构造函数作为一种合法方式，允许外部通过参数化的方式安全地设置这些私有数据的初始状态，而不会破坏封装性。</p><p>比如在上面的 <code>Person</code> 类中，<code>name</code> 和 <code>age</code> 都是私有的，外部无法直接访问或修改这些变量，但通过构造函数，我们可以在实例化时安全地初始化它们。</p><h4 id="实例化与封装数据的关系"><a href="#实例化与封装数据的关系" class="headerlink" title="实例化与封装数据的关系:"></a>实例化与封装数据的关系:</h4><p><strong>封装数据</strong> 是指将对象的内部数据隐藏起来，只能通过类内部的方法（如getter和setter）来访问或修改。实例化时，构造函数会为私有属性赋初值，从而完成对象的初始化。这种通过构造函数赋初值的方式，不仅符合封装的原则，也保证了数据的完整性和安全性。</p><h3 id="Public-Private-Protected-default"><a href="#Public-Private-Protected-default" class="headerlink" title="Public&amp;&amp;Private&amp;&amp;Protected&amp;&amp;default"></a>Public&amp;&amp;Private&amp;&amp;Protected&amp;&amp;default</h3><p>我们可以发现多数变量&#x2F;方法定义前都会带有public这样之类的修饰符，这有什么用，不同的修饰符又有什么区别呢？</p><ol><li><strong>public</strong>：可以被任何类访问。</li><li><strong>private</strong>：只能在定义它的类内部访问。</li><li><strong>protected</strong>：可以在同一包中的其他类和所有子类中访问。</li><li><strong>default</strong>（无修饰符）：仅在同一包中的类可以访问，称为包私有。</li></ol><p>到这里，Java的大致内容差不多已经学习完了，其余的内容将会在学习数据结构的过程中补充。</p><h2 id="IntList"><a href="#IntList" class="headerlink" title="IntList"></a>IntList</h2><p>数组是一个好用的工具，但是它的大小是固定的，为了解决这个问题，我们将搭建一个列表List.</p><p>List的基本框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要有<code>get()</code>来获取元素，<code>size()</code>标记大小。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">        <span class="keyword">public</span> IntList rest;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">            first = f;</span><br><span class="line">            rest = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the size of the listing using.....recursion</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rest.size() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(first, rest);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            totalSize += <span class="number">1</span>;</span><br><span class="line">            p = p.rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest.get(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 反向构建列表</span></span><br><span class="line">        <span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">25</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">35</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">45</span>, L);</span><br><span class="line">        System.out.println(L.size());</span><br><span class="line">        System.out.println(L.iterativeSize());</span><br><span class="line">        System.out.println(L.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SLList"><a href="#SLList" class="headerlink" title="SLList"></a>SLList</h2><h3 id="naked-recursive"><a href="#naked-recursive" class="headerlink" title="naked recursive"></a><strong>naked recursive</strong></h3><p>he issue is that the <code>IntList</code> is what I call a <strong>naked recursive</strong> data structure.(裸递归)</p><p>裸递归是指在处理递归数据结构时，直接使用递归调用而没有任何额外的处理或封装。<code>IntList</code> 的<code> size（）</code> 方法就是一个典型的例子。这个方法通过递归计算列表的大小。</p><p>“裸递归”的主要问题在于：</p><ol><li><strong>缺乏安全性</strong>：在递归调用中，如果没有明确的边界条件，可能会导致栈溢出（Stack Overflow）。</li><li><strong>可读性差</strong>：递归的逻辑可能不够直观，特别是对不熟悉递归的开发者来说。</li><li><strong>性能问题</strong>：某些情况下，递归调用会导致重复计算，影响效率。</li></ol><p>所以我们来优化它！！</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>相关代码如下：</p><p>将IntList重命名为IntNode,并作为SLList的嵌套类（nest class）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">    item = i;</span><br><span class="line">    next = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较创建对象时的好处：简化了操作。（Essentially, the <code>SLList</code> class acts as a middleman between the list user and the naked recursive data structure）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20102856.png" alt="屏幕截图 2024-10-24 102856"></p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;Pineapple&gt; &#123;</span><br><span class="line">    <span class="comment">// Dear user, you do not touch this...</span></span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Pineapple item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(Pineapple f, IntNode l)</span> &#123;</span><br><span class="line">            item = f;</span><br><span class="line">            next = l;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(Pineapple x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add items to the front of the list...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Pineapple i)</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(i, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pineapple <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Pineapple x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>&lt;&gt;</code>(例如<code>&lt;Pineapple&gt;</code>)是一种占位词，括号里面的可以是任何东西，使用它的时候要说明它的类型。</p><h2 id="DLList"><a href="#DLList" class="headerlink" title="DLList"></a>DLList</h2><p>SLList实现了从前向后依次查找，为了还可以从后往前，我们要搭建DLList。</p><p>仿照SLList的思路，我们在后面也布置一个哨兵。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104038.png" alt="屏幕截图 2024-10-24 104038"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104051.png" alt="屏幕截图 2024-10-24 104051"></p><p>此时，每个节点都可以访问前面与后面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往前一步，我们可以让两个哨兵合二为一。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104722.png" alt="屏幕截图 2024-10-24 104722"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104745.png" alt="屏幕截图 2024-10-24 104745"></p><p>大致代码结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;BleepBlorp&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> BleepBlorp item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>DLLIst</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;Integer&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="Alist"><a href="#Alist" class="headerlink" title="Alist"></a>Alist</h2><p>首先解释一下为什么要介绍Alist(也就是数组列表)，明明上节课的Dlist已经足够完美了，但我们在查找特定元素时，我们会发现Dlist无法直接一步到位，需要用到循环，但是如果是Alist的话，利用数组的特性就可以实现一步到位。啊哈，让我们从零开始建造Alist吧！！</p><p>实例化数组的三种方法：</p><ul><li><p><code>int[] x = new int[n];</code> (<code>x[0] = 1;</code>…)       </p></li><li><p><code>int[] y = new int&#123;1, 2, 3, 4, 5&#125;;</code></p></li><li><p><code>int[] z = &#123;9, 10, 11, 12, 13&#125;;</code></p><p>此外，数组复制Java也有自带的函数arraycopy().</p><p><code>int[] b = &#123;9, 10, 11&#125;; System.arraycopy(b, 0, x, 3, 2);</code></p><p>其中，各参数为：</p><ul><li>The array to use as a source</li><li>Where to start in the source array</li><li>The array to use as a destination</li><li>Where to start in the destination array</li><li>How many items to copy</li></ul></li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="comment">// size = 2</span></span><br><span class="line">    <span class="comment">// 5 6 0 8 0 0 0 0 0...</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create empty List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reSize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">        items = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            reSize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在resize方法中你会发现容量是成倍增长的。因为如果每当添加一个数，容量加一。可想而知，所消耗的时间是多么长，效率十分低。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20203035.png" alt="屏幕截图 2024-10-15 203035"></p><p>虽然提高了效率，但当数组十分大的时候，再运用这个方法，就会有大量的空缺，造成大量的内存浪费。</p><p>上述代码仅适用于int类型，为了它更好地发挥它的作用，我们要用到我们的老朋友占位词。但是这里我们发现对数组直接使用占位词，你会发现有问题。这里我直接引用Qingsu关于这个问题的解决方案（如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20204117.png" alt="屏幕截图 2024-10-15 204117"></p><h2 id="Inheritance-I"><a href="#Inheritance-I" class="headerlink" title="Inheritance I"></a>Inheritance I</h2><h3 id="Override-default-interface"><a href="#Override-default-interface" class="headerlink" title="Override &amp;&amp; default &amp;&amp; interface"></a>Override &amp;&amp; default &amp;&amp; interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">longestString</span> <span class="operator">=</span> list.get(maxDex);</span><br><span class="line">        <span class="type">String</span> <span class="variable">thisString</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        <span class="keyword">if</span> (thisString.length() &gt; longestString.length()) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(maxDex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码想要接受的变量类型想要是<code>ALList&lt;String&gt;</code>,我们可能又要重写一遍，但我们发现之前ALList与SLList所拥有的方法差不多，我们可以使用一个类似购物清单的接口，上面写着所要实现的方法,关键词<code>interface</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;cheese&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的大多数方法都只告诉有什么方法，具体操作要在子类中实现(<code>implements</code>)，所使用的关键词是<code>Override</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &lt;cheese&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;cheese&gt;&#123;</span><br><span class="line">    <span class="comment">// size = 2</span></span><br><span class="line">    <span class="comment">// 5 6 0 8 0 0 0 0 0...</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">    <span class="keyword">private</span> cheese[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create empty List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (cheese[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reSize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cheese[] temp = (cheese[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">        items = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            reSize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">cheese</span> <span class="variable">last</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;cheese&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;cheese&gt; &#123;</span><br><span class="line">    <span class="comment">// Dear user, you do not touch this...</span></span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> cheese item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(cheese f, IntNode l)</span> &#123;</span><br><span class="line">            item = f;</span><br><span class="line">            next = l;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add items to the front of the list...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(cheese i)</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(i, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SLList&lt;String&gt; L1 = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        L1.addFirst(<span class="string">&quot;What&quot;</span>);</span><br><span class="line"></span><br><span class="line">        L1.addLast(<span class="string">&quot;THis&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(L1.getFirst ());</span><br><span class="line"></span><br><span class="line">        SLList&lt;Integer&gt; L2 = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Integer&gt;();</span><br><span class="line">        L2.addFirst(<span class="number">10</span>);</span><br><span class="line">        L2.addLast(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一些接口中的方法也会编写一个默认的方法（使用关键词<code>default</code>）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>倘若不想要接口中的默认方法，也可以覆盖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dynamic-method-selection"><a href="#dynamic-method-selection" class="headerlink" title="dynamic method selection"></a><strong>dynamic method selection</strong></h3><p>java会怎么选择哪一个方法来调用呢？—– 动态方法选择</p><p><code>List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</code></p><p>在上面的声明和实例化中，lst的类型是“List61B”。这被称为“静态类型”</p><p>然而，对象本身也有类型。lst指向的对象是SLList类型的。尽管这个对象本质上是一个SLList（因为它是这样声明的），但它也是一个List61B。但是，由于对象本身是使用SLList构造函数实例化的，因此我们称其为“动态类型”。</p><p>如果lst被重新赋值指向另一种类型的对象，比如一个Alist对象，那么lst的动态类型现在将是Alist而不是SLList！它是动态的，因为它根据当前引用的对象类型而改变。</p><p>当Java运行被覆盖的方法时，它会在其动态类型中搜索适当的方法签名并运行它。</p><p>当java有两个名称相同参数不同的方法，Java检查要调用哪个方法时，它检查静态类型并调用具有相同类型参数的方法。</p><h3 id="Superclass-Subclass"><a href="#Superclass-Subclass" class="headerlink" title="Superclass &amp;&amp; Subclass"></a>Superclass &amp;&amp; Subclass</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-27%20112203.png"></p><p>作为超类的接口以及继承它的子类关系如上。</p><h2 id="Inheritance-II"><a href="#Inheritance-II" class="headerlink" title="Inheritance II"></a>Inheritance II</h2><h3 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h3><p>到目前为止，我们一直在编写类和接口，您可能已经注意到我们必须为不同或相似的类编写冗余代码的地方。因此，我们有了继承的概念：一个类&#x2F;对象不需要重新定义它的所有方法，而是可以使用父类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;Blorp&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Blorp&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="type">Blorp</span> <span class="variable">oldBack</span> <span class="operator">=</span> removeLast();</span><br><span class="line">              addFirst(oldBack);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because of extends, RotatingSLList inherits all members of SLList:</p><ul><li>All instance and static variables.</li><li>All methods.</li><li>All nested classes.</li><li>Constructors are <strong>not</strong> inherited!</li></ul><p>在Java中，<code>extends</code> 和 <code>implements</code> 是用来实现类和接口之间关系的两个关键字。它们的关系与区别如下：</p><h4 id="1-extends"><a href="#1-extends" class="headerlink" title="1. extends"></a>1. <code>extends</code></h4><ul><li><p><strong>作用</strong>：用于表示一个类继承另一个类。子类可以继承父类的属性和方法。</p></li><li><p><strong>单继承</strong>：Java 中的类只能直接继承一个父类，即支持单继承。</p></li><li><p><strong>语法</strong>：<code>class 子类名 extends 父类名 &#123; &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系图如下：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10list_subclasses.png" alt="list_subclasses"></p><h4 id="2-implements"><a href="#2-implements" class="headerlink" title="2. implements"></a>2. <code>implements</code></h4><ul><li><p><strong>作用</strong>：用于表示一个类实现一个或多个接口。类必须实现接口中定义的所有方法。</p></li><li><p><strong>多实现</strong>：一个类可以实现多个接口，这支持了Java的多重继承特性（虽然类本身不支持多继承）。</p></li><li><p><strong>语法</strong>：<code>class 类名 implements 接口名1, 接口名2 &#123; &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sound</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Sound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-关系与区别"><a href="#3-关系与区别" class="headerlink" title="3. 关系与区别"></a>3. 关系与区别</h4><ul><li>关系<ul><li><code>extends</code> 主要用于类之间的继承关系，形成类的层次结构。</li><li><code>implements</code> 主要用于类与接口之间的实现关系，允许类遵循某种协议或行为。</li></ul></li><li>区别<ul><li>继承（<code>extends</code>）会带来代码重用，可以直接使用父类的方法和属性，而实现（<code>implements</code>）则需要在类中提供具体的方法实现。</li><li>在继承中，子类只可以有一个直接父类；而实现中，一个类可以实现多个接口，增加了灵活性。</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>使用 <code>extends</code> 时，类之间形成父子关系，支持单继承；使用 <code>implements</code> 时，类与接口之间形成实现关系，支持多实现。这两者各有用途，适用于不同的设计场景。</li></ul><h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><p>this和super功能上相似：</p><p><strong>this</strong>: 引用当前对象.<code>this</code> 关键字用于引用当前对象的成员变量和方法。它可以帮助区分局部变量和实例变量，特别是在构造函数中。</p><p><strong>super</strong>:访问父类成员：<code>super</code> 关键字用于访问父类的成员变量和方法。当子类与父类有同名的成员变量或方法时，可以使用 <code>super</code> 来明确访问父类的成员。</p><h4 id="super-和-this-的关系"><a href="#super-和-this-的关系" class="headerlink" title="super 和 this 的关系"></a><code>super</code> 和 <code>this</code> 的关系</h4><ul><li><p><code>this</code> 和 <code>super</code> 可以在构造函数中同时使用。可以在构造函数的第一行使用 <code>super()</code> 调用父类的构造函数，或者使用 <code>this()</code> 调用同类的另一个构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Child() &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><h4 id="1-Java封装（Encapsulation）"><a href="#1-Java封装（Encapsulation）" class="headerlink" title="1. Java封装（Encapsulation）"></a>1. Java封装（Encapsulation）</h4><ul><li><p><strong>定义</strong>：封装是将对象的状态（属性）和行为（方法）绑定在一起，并通过访问控制修饰符来限制对内部状态的直接访问。</p></li><li><p><strong>实现方式</strong>：</p><ul><li><strong>访问修饰符</strong>：Java提供了几种访问修饰符（如 <code>private</code>、<code>protected</code>、<code>public</code> 和包级别）来控制类的成员（变量和方法）的可见性。</li><li><strong>Getter 和 Setter 方法</strong>：通常，通过提供公共的 Getter 和 Setter 方法来访问和修改私有属性，以实现对对象状态的控制。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name; // 私有属性</span><br><span class="line"></span><br><span class="line">    // Getter 方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Setter 方法</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-模块封装"><a href="#2-模块封装" class="headerlink" title="2. 模块封装"></a>2. 模块封装</h4><ul><li><p><strong>定义</strong>：模块封装是Java 9引入的概念，用于对类和包进行更高层次的组织。模块是一个包含相关包的集合，模块可以定义自己的公共API，并隐藏内部实现。</p></li><li><p><strong>功能</strong>：模块可以控制哪些类和包是公开的，哪些是私有的，通过 <code>module-info.java</code> 文件来声明模块的依赖关系和导出内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module com.example &#123;</span><br><span class="line">    exports com.example.api; // 导出公共API</span><br><span class="line">    requires com.othermodule; // 依赖其他模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-封装与模块封装的关系"><a href="#3-封装与模块封装的关系" class="headerlink" title="3. 封装与模块封装的关系"></a>3. 封装与模块封装的关系</h4><ul><li><strong>层次</strong>：<ul><li>封装是对类和对象的管理，它主要关注于如何保护对象的状态和行为，限制外部对对象内部状态的直接访问。</li><li>模块封装则是在更高层次上组织代码，关注的是如何将一组相关的类和包组合在一起，提供公共接口，并管理模块之间的依赖关系。</li></ul></li><li><strong>互补性</strong>：<ul><li>封装确保了类的内部实现细节被隐藏，而模块封装则确保了整个模块的内部实现细节被隐藏。二者结合使用可以提高代码的可维护性和可重用性。</li></ul></li></ul><h3 id="Higher-Order-Functions-in-Java"><a href="#Higher-Order-Functions-in-Java" class="headerlink" title="Higher Order Functions in Java"></a>Higher Order Functions in Java</h3><p>Java中参数可以间接传递函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HoFDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inheritance-III"><a href="#Inheritance-III" class="headerlink" title="Inheritance III"></a>Inheritance III</h2><h3 id="Subtype-Polymorphism"><a href="#Subtype-Polymorphism" class="headerlink" title="Subtype Polymorphism"></a>Subtype Polymorphism</h3><p>子类型多态性（Subtype Polymorphism）是面向对象编程中的一个重要特性，尤其在Java中广泛应用。以下是子类型多态性的作用和意思的详细解释。</p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>子类型多态性指的是在一个继承层次结构中，子类对象可以被视为其父类类型的对象。这意味着你可以使用父类引用指向子类的实例，从而在运行时根据对象的实际类型调用相应的方法。</p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><ul><li><strong>灵活性</strong>：通过使用父类引用，可以在不修改代码的情况下扩展功能。只需添加新的子类并实现父类的方法，程序就可以处理新的子类对象。</li><li><strong>可替换性</strong>：子类型多态性使得可以在代码中使用任何子类实例，而不需要关注具体的子类类型。这使得代码更具通用性和可维护性。</li><li><strong>提高代码复用</strong>：父类中的方法可以被多个子类共享，减少了代码重复，提高了代码的复用性。</li><li><strong>实现接口和抽象类的多态性</strong>：在使用接口和抽象类时，可以实现更强大的多态性，允许不同的实现方式而不影响调用代码。</li></ul><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><p>下面是一个简单的示例，展示子类型多态性的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog对象被视为Animal类型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// Cat对象被视为Animal类型</span></span><br><span class="line"></span><br><span class="line">        myDog.sound(); <span class="comment">// 输出: Bark</span></span><br><span class="line">        myCat.sound(); <span class="comment">// 输出: Meow</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>myDog</code> 和 <code>myCat</code> 都是 <code>Animal</code> 类型的引用，但它们指向不同的子类对象。当调用 <code>sound()</code> 方法时，实际调用的是它们各自的实现。</p><p>我们现在用子类型多态性来搭建一个比较大小的代码：</p><p>先创建一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类以Dog来举例（难怪说狗是人类最好的朋友（bushi）)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; says:\&quot;Bark\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体比较大小（仍然以狗为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Maximizer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Maximizer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxDex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> items[maxDex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[]&#123;d1, d2, d3&#125;;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog)max(dogs);</span><br><span class="line">        maxDog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inheritance-IV-iterators"><a href="#Inheritance-IV-iterators" class="headerlink" title="Inheritance IV iterators"></a><strong>Inheritance IV iterators</strong></h2><h3 id="Iterators-and-Iterables"><a href="#Iterators-and-Iterables" class="headerlink" title="Iterators and Iterables"></a>Iterators and Iterables</h3><p>在讲迭代器与可迭代对象之前，补充一下集合的简略代码(可以完成添加不重复的物品，以及查看集合是否包含这个元素)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>]; <span class="comment">// we can abjust the size/resize, just like we did in the array list </span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Adds an item to the set. (Ignores duplicates.) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contain</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (items[i].equal(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器与可迭代对象</strong>。这部分内容实际上就是 python 中迭代器的概念加上上文提到的用 Java 实现比较器的手段</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20191256.png" alt="屏幕截图 2024-10-09 191256"></p><p>我们可以从上面这张图发现新的遍历方法（java call this the enhanced for loop) ,我们将在揭开它的神秘面纱的过程中，了解迭代器与可迭代对象。</p><p>由于上面写了一个模拟集合的代码（不是java自带的），因此没有迭代器，所以如果使用enhanced loop,就会出现下面这种情况。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20193351.png" alt="屏幕截图 2024-10-09 193351"></p><p>迭代器相当于一个小巫师，它会检查ArraySet,一步步地遍历ArraySet逐一返回项</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20204929.png" alt="屏幕截图 2024-10-09 204929"></p><p>搞错了（bushi）!?</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20204457.png" alt="屏幕截图 2024-10-09 204457"></p><p>相关的接口代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上我们实现了可迭代版本的 Arraysets，完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">       Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** returns an iterator (a.k.a. seer) into ME */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            wizPos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">            wizPos += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset.add(<span class="number">5</span>);</span><br><span class="line">        aset.add(<span class="number">23</span>);</span><br><span class="line">        aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iteration</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-methods"><a href="#Object-methods" class="headerlink" title="Object methods"></a>Object methods</h3><p>如上文所述，Java 中所有的类都是 Object 类的子类，也可以说 Object 是最顶端的 superclass，继承的方法如下：</p><ul><li><code>String toString()</code></li><li><code>boolean equals(Object obj)</code></li><li><code>Class &lt;?&gt; getClass()</code></li><li><code>int hashCode()</code></li><li><code>protected Objectclone()</code></li><li><code>protected void finalize()</code></li><li><code>void notify()</code></li><li><code>void notifyAll()</code></li><li><code>void wait()</code></li><li><code>void wait(long timeout)</code></li><li><code>void wait(long timeout, int nanos)</code></li></ul><p>这里专注理解前两个即可</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>相当于将某个对象字符串化的时候该怎么办？toString()解决的就是这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x += i.toString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在Java中，如果你试图将两个字符串加在一起，你实际上正在创建一个全新的字符串，打个比方，纸质书籍如果有错误或者需要加一些新内容，肯定要重新编辑，在印刷出来，这样一定会需要时间，实际上这与字符串不可变有关。</p><p>所以让我们来改进一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 借用Java自带的类</span></span><br><span class="line">    x.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x.append(i.toString());</span><br><span class="line">        x.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    x.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x.toString(); <span class="comment">// 原本类型是StringBuilder,需要转换成String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边还有一个问题，为什么”for(T i : this)”中用this,而不用items.</p><p>因为用items可能会有空值，而this刚刚好。</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h4><p>关于这个关键词，老面孔了，它有什么作用呢？</p><p>他会告诉你一个指向当前对象的引用。</p><p>与new关键词异曲同工，不过，他喊的不是新创建对象的地址，而是当前对象的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20212635.png" alt="屏幕截图 2024-10-09 212635"></p><p>但有时我们会发现，size与this.size似乎是等价的；</p><p>这是为什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20212914.png" alt="屏幕截图 2024-10-09 212914"></p><p>当变量有同名变量时，不可以互转，因为Java不知道哪个是哪个。</p><p>this 还可以代替构造方法名，实现构造方法的调用,但它只能在构造方法中调用，且只能在第一句,不能与 <code>super()</code> 一起使用，除非是通过 <code>super()</code> 先调用父类构造方法，然后通过其他构造方法继续调用当前类的构造方法（隐含顺序决定：<code>super()</code> 总是先调用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>); <span class="comment">// 调用另一个构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">0</span>); <span class="comment">// 调用带两个参数的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用带一个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带两个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();       <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用带一个参数的构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); <span class="comment">// 直接调用带两个参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出等价使用new方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用new创建对象并获取其字段值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">tempPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = tempPerson.name;</span><br><span class="line">        <span class="built_in">this</span>.age = tempPerson.age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用new创建对象并获取其字段值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">tempPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = tempPerson.name;</span><br><span class="line">        <span class="built_in">this</span>.age = tempPerson.age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带一个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带两个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();       <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用带一个参数的构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); <span class="comment">// 直接调用带两个参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>注意，Java 中 <code>==</code> 在比较对象的时候实际上比较的是<strong>二者是否是同一个对象</strong>，即二者存储的地址是否相同。而这显然不符合特定情况下我们的要求，所以我们采取 <code>equals</code> 来<strong>重载我们的 <code>=</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArraySet otherArraySet) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上图我们又发现了“instanceof”这个奇怪的关键词，它是在判断o是否时ArraySet的一个实例,同时，我们又注意到otherAccaySet,这又是什么鬼东西？原来，如果前面的判断为true，他会为你执行一个额外的操作，即它将创建一个名为otherArraySet的新变量，类型为ArraySet.换句话说，它和o是一样的，他们包含相同的引用。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214128.png" alt="屏幕截图 2024-10-09 214128"></p><p>话又说回来，如何判断两个数组大小相同呢？</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214337.png" alt="屏幕截图 2024-10-09 214337"></p><p>大小相同，并且有互相的东西–“你有，我也有”</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214543.png" alt="屏幕截图 2024-10-09 214543"></p><h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p>异常会导致正常的控制流停止。实际上，我们可以选择抛出自己的异常。在 Python 中，您可能已经看到过这种情况，使用 <code>raise</code> 关键字。在 Java 中，异常是对象，我们使用以下格式抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionObject</span>(parameter1, ...)</span><br></pre></td></tr></table></figure><p>一个典型例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Associates the specified value with the specified key in this map.</span><br><span class="line">   Throws an IllegalArgumentException if the key is null. */</span><br><span class="line">public void add(T x) &#123;</span><br><span class="line">    if (x == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;can&#x27;t add null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (contains(x)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这么做？以下是课本原文：</p><p>We get an Exception either way - why is this better?</p><ol><li>We have control of our code: we consciously decide at what point to stop the flow of our program</li><li>More useful Exception type and helpful error message for those using our code</li></ol><p>However, it would be better if the program doesn’t crash at all. There are different things we could do in this case. Here are some below:</p><p><strong>Approach 1</strong>: Don’t add <code>null</code> to the array if it is passed into <code>add</code></p><p><strong>Approach 2</strong>: Change the <code>contains</code> method to account for the case if <code>items[i] == null</code>.</p><p>Whatever you decide, it is important that users know what to expect. That is why documentation (such as comments about your methods) is very important</p><h2 id="Disjoint-Sets"><a href="#Disjoint-Sets" class="headerlink" title="Disjoint Sets"></a>Disjoint Sets</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>不相交集在名字上听起来像是数学上的<code>A∩B=0</code>,打一个日常生活的例子，比如世界地图，我们可以很清晰的看出国家之间的地理位置（国界是否接壤可以很清晰地看出来），或者，搭建桥梁连接两地，不相交集就是为了用代码表示诸如类似的情况。</p><p>为了判断是否连接和搭建连接，搭建不相交集需要以下两个操作：</p><ol><li><code>connect(x, y)</code>: Connects x and y</li><li><code>isConnected(x, y)</code>: Return true if x and y are connected</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** connects two items P and Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** checks to see if two items are connected */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不相交集的大致作用如下：</p><p>假设我们有四个元素如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro1_resized.png" alt="intro1_resized"></p><p>在调用<code>connect(A, B)</code>后：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro2_resized.png" alt="intro2_resized"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isConnected<span class="function"><span class="params">(A, B)</span> -&gt;</span> <span class="literal">true</span>;</span><br><span class="line">isConnected<span class="function"><span class="params">(A, C)</span> -&gt;</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>在调用 <code>connect(A, D)</code> 后：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro3_resized.png" alt="intro3_resized"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isConnected<span class="function"><span class="params">(A, D)</span> -&gt;</span> <span class="literal">true</span></span><br><span class="line">isConnected<span class="function"><span class="params">(A, C)</span> -&gt;</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从上述过程，我们可以发现<code>&#123;A&#125;, &#123;B&#125;, &#123;C&#125;, &#123;D&#125;</code>，通过一系列操作，变成了<code>&#123;A, B, D&#125;, &#123;C&#125;</code>,如何表示这个变化呢？我们可以用列表表示(<code>List&lt;Set&lt;Integger&gt;&gt;</code>): <code>[&#123;A, B, D&#125;, &#123;C&#125;]</code></p><h3 id="ListOfSetsDS"><a href="#ListOfSetsDS" class="headerlink" title="ListOfSetsDS"></a>ListOfSetsDS</h3><p><code>isConected</code>: 需要遍历列表中的所有集合来判断是否连接在一起。</p><ul><li><strong>时间复杂度</strong>：以最坏的情况来看（假设有N个集合），如果没有连接，且又在末尾，O(N)+O(N-1) &#x3D; O(N).</li></ul><p><code>connect</code>: 需要遍历所有集合，且代码十分复杂。</p><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h3><p>我们进行第一次优化，将不相交集合用数组的方式来实现：</p><ul><li>The <strong>indices of the array</strong> represent the elements of our set.</li><li>The <strong>value at an index</strong> is the set number it belongs to.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/109.2.1.png" alt="9.2.1"></p><p><code>connect(x, y)</code>: 将其中一个位置的id修改为另一个的id即可</p><ul><li>时间复杂度：O(N)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(4).png" alt="image (4)"></p><p><code>isConnected(x, y)</code>: 查看两个位置的元素是否相同</p><ul><li>时间复杂度：O(1)</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* need to iterate through the array =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="quick-union"><a href="#quick-union" class="headerlink" title="quick union"></a>quick union</h3><p>课本原话：</p><p>we assign each item the index of its parent. If an item has no parent, then it is a ‘root’ and we assign it a negative value.</p><ul><li>the nodes will be the items in our set,</li><li>each node only needs a reference to its parent rather than a direct reference to the face of the set, and</li><li>the top of each tree (we refer to this top as the “root” of the tree) will be the face of the set it represents.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(5).png" alt="image (5)"></p><p><code>connect(x, y)</code>: 假如我们要合并最左边的与中间的，我们要先找到两个对应的父链，再只需要将索引为3的元素改成0（为什么不是将索引为零的元素改成3之后会讨论）。</p><ul><li><p>时间复杂度:：O(N)</p></li><li><p><input disabled="" type="checkbox"> 分支任务1：为什么不是将索引为零的元素改成3</p></li></ul><p><code>isConnected(x, y)</code>:只要看所对应的父链是否相等。</p><ul><li>时间复杂度：O(N)</li></ul><p>为了完成quick union,还需要<code>find</code>寻找<code>item</code>所归属的根。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码还会引发一个问题：会产生如下图丑陋的结构</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10worst.png" alt="worst"></p><p>为了避免这个问题，我们要进行如下优化：</p><h4 id="weight-quick-union"><a href="#weight-quick-union" class="headerlink" title="weight quick union"></a>weight quick union</h4><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-21%20175018.png" alt="屏幕截图 2024-10-21 175018"></p><p>对于上述情况，我们是选择将T1连接到T2下还是将T2连接到T1下呢？</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(6).png" alt="image (6)">当我们有两个不同大小的树，进行这个连接操作时，应该始终选择较小的树，并将其放在较大的树的下面（如上图)，这样合成的树的深度会比另一种情况矮，遍历一个分支的速度会快很多。</p><ul><li><input checked="" disabled="" type="checkbox"> 分支任务1：为什么不是将索引为零的元素改成3</li></ul><p>一个巧妙的跟踪大小的方法，在父链所代表的元素上显示大小，也就是-1换成大小取负号。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10initial.png" alt="initial"></p><p>调用<code>union(0,1)</code> 与 <code>union(2,3)</code>后：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10union1.png" alt="union1"></p><h4 id="Weighted-Quick-Union-with-Path-Compression"><a href="#Weighted-Quick-Union-with-Path-Compression" class="headerlink" title="Weighted Quick Union with Path Compression"></a>Weighted Quick Union with Path Compression</h4><p>课本原文：</p><p>A clever optimization is to move the leaf up the tree so it becomes a direct child of the root. That way, the next time you call on that leaf, it will run much more quickly. An even more clever idea is that we could do the same thing to <em>every</em> node that is on the path from the leaf to the root. Specifically, when we call on an item, all of the nodes that were traversed upon going up the tree (to the root) are updated so that they are now connected directly to the root. This optimization is called <strong>path compression</strong>. Once you find an item, path compression will make finding it (and all the nodes on the path to the root) in the future faster.</p><p>大意：从底部的<code>item</code>往上爬，在此过程中，将路径上的<code>item</code>连接到它们的根。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10path_compression_before.png" alt="path_compression_before"></p><p>After we call on , all of the nodes we traversed to get to the root are updated so that they now connect directly to the root:<code>find(5)</code></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10path_compression_after.png" alt="path_compression_after"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>N: number of elements in Disjoint Set</p><table><thead><tr><th>Implementation</th><th><code>isConnected</code></th><th><code>connect</code></th></tr></thead><tbody><tr><td>Quick Find</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>Quick Union</td><td>O(N)</td><td>O(N)</td></tr><tr><td>Weighted Quick Union (WQU)</td><td>O(log N)</td><td>O(log N)</td></tr><tr><td>WQU with Path Compression</td><td>O(α(N))*</td><td>O(α(N))*</td></tr></tbody></table><h2 id="ADTS（Abstract-Data-Type）"><a href="#ADTS（Abstract-Data-Type）" class="headerlink" title="ADTS（Abstract Data Type）"></a>ADTS（Abstract Data Type）</h2><p>抽象数据结构(ADT)侧重于告诉你能做什么(What)，而不是具体告诉你怎么做(How)。</p><p>(Abstract data types (ADTs) are defined in terms of operations, not implementation.)</p><p>Some commonly used ADT’s are:</p><ul><li>Stacks: Structures that support last-in first-out retrieval of elements<ul><li><code>push(int x)</code>: puts x on the top of the stack</li><li><code>int pop()</code>: takes the element on the top of the stack</li></ul></li><li><strong>Lists</strong>: an ordered set of elements<ul><li><code>add(int i)</code>: adds an element</li><li><code>int get(int i)</code>: gets element at index i</li></ul></li><li><strong>Sets</strong>: an unordered set of unique elements (no repeats)<ul><li><code>add(int i)</code>: adds an element</li><li><code>contains(int i)</code>: returns a boolean for whether or not the set contains the value</li></ul></li><li><strong>Maps</strong>: set of key&#x2F;value pairs<ul><li><code>put(K key, V value)</code>: puts a key value pair into the map</li><li><code>V get(K key)</code>: gets the value corresponding to the key</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/1010%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20153010.png" alt="屏幕截图 2024-10-19 153010"></p><h3 id="BST（Binary-Search-Trees）"><a href="#BST（Binary-Search-Trees）" class="headerlink" title="BST（Binary Search Trees）"></a>BST（Binary Search Trees）</h3><h4 id="Derivation"><a href="#Derivation" class="headerlink" title="Derivation"></a>Derivation</h4><p>用链表一步步搭建二叉搜索树的雏形：</p><ol><li><p>首先，要保证是有序的。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20154834.png" alt="屏幕截图 2024-10-19 154834"></p></li><li><p>为了提高效率，直接从中间开始</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20154904.png" alt="屏幕截图 2024-10-19 154904"></p></li><li><p>我们继续优化它，使它每一次都从指定区域的中间开始</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image.png" alt="image"></p></li></ol><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>在了解二叉搜索树之前，我们要先了解树的定义：</p><p>Trees are composed of:</p><ul><li>nodes </li><li>edges that connect those nodes. – 连接节点的线<ul><li><strong>Constraint</strong>: there is only one path between any two nodes.（两个节点只有唯一的路径）</li></ul></li></ul><p>In some trees, we select a <strong>root</strong> node which is a node that has no parents. </p><p>A tree also has <strong>leaves</strong>, which are nodes with no children.</p><p>进一步我们来了解Rooted Trees 和 Rooted Binary Trees</p><ul><li>Every node N except the root has exactly one parent,defined as the first node on the path from N to the root.</li><li>Unlike (most)real trees, the root is usually dispicted at the top of the tree.</li><li>A node with no child is called a leaf.</li></ul><p>In a rooted binery tree, every node has either 0, 1, or 2   </p><p>childreb(subtrees)</p><p>最后我们有<strong>二叉树</strong>和<strong>二叉搜索树</strong>的定义：</p><ul><li><p><strong>Binary Trees</strong>: in addition to the above requirements, also hold the binary property constraint. That is, each node has either 0, 1, or 2 children.</p></li><li><p>Binary Search Trees</p><p>: in addition to all of the above requirements, also hold the property that For every node X in the tree:</p><ul><li>Every key in the left subtree is less than X’s key.</li><li>Every key in the right subtree is greater than X’s key. <strong>Remember this property!! We will reference it a lot throughout the duration of this module and 61B.</strong></li></ul></li></ul><p><strong>Rule</strong>：No duplicate keys allowed.(没有重复)</p><p>Here is the BST class we will be using in this module:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST left, BST Right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><p>类比二分查找，当我们想要查找 BST 中的数据的时候，思路是同样的：</p><ul><li>和当前结点的值比大小，若是则返回</li><li>若是小于待查值，则往右拐</li><li>若是大于待查值，则往左拐</li></ul><p>如果树很茂密，那么树的高度 H &#x3D; log N，即意味着查找用时也是 log N.</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sk.equals(T.key))</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sk &lt; T.key)</span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>Search for key:</p><ul><li><p>If found, do nothing</p></li><li><p>If not found:</p><ul><li><p>Crete new node.</p></li><li><p>Set appropriate link</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key ik)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">  <span class="keyword">if</span> (ik ≺ T.key)</span><br><span class="line">    T.left = insert(T.left, ik);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ik ≻ T.key)</span><br><span class="line">    T.right = insert(T.right, ik);</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>3 Case:</p><ul><li>Deletion key has no children.</li><li>Deletion key has one children.</li><li>Deletion key has two children.</li></ul><p>对于第一种情况，直接让父链不再指向它，转身指向null.</p><p>对于第二种情况，让父节点把原本指向要删除的节点的指针指向它的子节点。</p><p>对于第三种情况，在要删除的节点下的子节点中找到一个合适的替换该要删除的节点。</p><h4 id="Map-VS-Set"><a href="#Map-VS-Set" class="headerlink" title="Map VS Set"></a>Map VS Set</h4><p>以下是课本原文：</p><p>We can use a BST to implement the <code>Set</code> ADT. If we use a BST, we can decrease the runtime of <code>contains</code> to log⁡(n)log(<em>n</em>) because of the BST property which enables us to use binary search!</p><p>We can also make a binary tree into a map by having each BST node hold <code>(key,value)</code> pairs instead of singular values. We will compare each element’s key in order to determine where to place it within our tree.</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        left = right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉搜索树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化根节点为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个新的值到二叉搜索树中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = insertRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地插入一个值</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right, value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索某个值是否存在于二叉搜索树中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地搜索某个值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历二叉搜索树（从小到大排序）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">()</span> &#123;</span><br><span class="line">        inorderRec(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地进行中序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderRec(root.left);</span><br><span class="line">            System.out.print(root.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            inorderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = deleteRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地删除某个值</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deleteRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value) &#123;</span><br><span class="line">            root.left = deleteRec(root.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value) &#123;</span><br><span class="line">            root.right = deleteRec(root.right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点只有一个子节点或者没有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该节点有两个子节点，找到中序后继（右子树的最小值）</span></span><br><span class="line">            root.value = minValue(root.right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除中序后继</span></span><br><span class="line">            <span class="comment">//root.right = deleteRec(root.right, root.value);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小值节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> root.value;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            minValue = root.left.value;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Balance-Trees"><a href="#Balance-Trees" class="headerlink" title="Balance Trees"></a>Balance Trees</h3><h4 id="Height-and-Depth"><a href="#Height-and-Depth" class="headerlink" title="Height and Depth"></a>Height and Depth</h4><p>高度与深度在BST中是十分重要的特征，决定BST的运行时间。</p><p>首先，高度与深度的关系如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(2).png" alt="image (2)"></p><p>其次，不同的插入方式可能造成同样的高度中存放不同数量的元素（如下图）：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(1).png" alt="image (1)"></p><p>通过观察，我们发现左边的树十分茂密，而右边的树十分稀疏。这会造成如下的情形：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(3).png" alt="image (3)"></p><p>我们可以发现稀疏的树的平均深度比茂密的树的平均深度要大，这表明左边的运行时间会较大。</p><p>为了避免这种不平衡的情况（稀疏的情况），我们将讨论B-Tree</p><h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20202148.png" alt="屏幕截图 2024-10-19 202148"></h4><p>当子节点中元素等于4个，将会分裂，中间偏左的元素会到上一级，之前在它左边的和右边的分别当作它的子节点。</p><h4 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h4><p>B-Tree具有以下有用的不变性：</p><ul><li>All leaves must be the same distance from the source.</li><li>A non-leaf node with 𝑘 items must have exactly 𝑘+1 children.</li></ul><p>In tandem, these invariants cause the tree to always be bushy.</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20203629.png" alt="屏幕截图 2024-10-19 203629"></p><p>节点可以存放元素的个数等于这棵树的高度</p><h4 id="Runtime-for-contains"><a href="#Runtime-for-contains" class="headerlink" title="Runtime for contains"></a>Runtime for <code>contains</code></h4><p>In the worst case, we have to examine up to L<em>L</em> items per node. We know that height is logarithmic, so the runtime of <code>contains</code> is bounded by O(Llog⁡N)<em>O</em>(<em>L</em>log<em>N</em>). Since L<em>L</em> is a constant, we can drop the multiplicative factor, resulting in a runtime of O(log⁡N).</p><h4 id="Runtime-for-add"><a href="#Runtime-for-add" class="headerlink" title="Runtime for add"></a>Runtime for <code>add</code></h4><p>A similar analysis can be done for <code>add</code>, except we have to consider the case in which we must split a leaf node. Since the height of the tree is O(log⁡N)<em>O</em>(log<em>N</em>), at worst, we do log⁡Nlog<em>N</em> split operations (cascading from the leaf to the root). This simply adds an additive factor of log⁡Nlog<em>N</em> to our runtime, which still results in an overall runtime of O(log⁡N).</p><h2 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red Black Trees"></a>Red Black Trees</h2><p>即使B-Tree十分平衡均匀，但实际跟踪要分裂的节点是十分复杂的。因此，我们需要另辟蹊径创造一个全新的B-Tree.</p><h3 id="Rotating-Tree"><a href="#Rotating-Tree" class="headerlink" title="Rotating Tree"></a>Rotating Tree</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20164235.png" alt="屏幕截图 2024-10-24 164235"></p><p>对于上面这张图，即使树的结构千姿百态，但所包含的元素却是相同的。为了获得矮小的树，我们引入旋转的方法（如下图所示）。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20164720.png" alt="屏幕截图 2024-10-24 164720"></p><p>我们想让<code>G</code>向左旋转，过程可以看作是<code>G</code>与与它相连的右节点<code>P</code>暂时融合，然后把想要旋转的节点发射到左边，并且连接一两条分支。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return x</code>是为了得知<code>parent node</code>指向哪个节点！</p><h3 id="Create-LLRB-Trees"><a href="#Create-LLRB-Trees" class="headerlink" title="Create LLRB Trees"></a>Create LLRB Trees</h3><p>红黑树有几个重要的性质：</p><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL节点）是黑色。</li><li>如果一个节点是红色，则它的两个子节点必须是黑色（即不允许有两个连续的红色节点）。</li><li>从任何节点到其每个叶子节点的所有路径都必须包含相同数量的黑色节点。</li></ul><p>以2-3树为例</p><p>对于一个有多个项目的节点，我们可以利用之前创造链表的思路设置一个哨兵：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20173652.png" alt="屏幕截图 2024-10-24 173652"></p><p>但这个节点有点浪费，我们有更好的处理方式：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20173818.png" alt="屏幕截图 2024-10-24 173818"></p><p><code>We show that a link is a glue link by making it red. Normal links are black.</code>因此 我们称它为 <strong>left-leaning red-black trees (LLRB)</strong>. </p><p><strong>关于LLRB特点</strong></p><p>课本原文：</p><ul><li>1-1 correspondence with 2-3 trees.</li><li>No node has 2 red links.</li><li>There are no red right-links.</li><li>Every path from root to leaf has the same number of black links (because 2-3 trees have the same number of links to every leaf).</li><li>Height is no more than 2x height + 1 of the corresponding 2-3 tree. </li><li>The height of a red-black tree is proportional to the log of the number of entries.</li></ul><h4 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h4><p>左倾红黑树，说明了红线是在左边的.</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181208.png" alt="屏幕截图 2024-10-24 181208"></p><p>同一个节点的同一侧不能有两条红色链接:</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181223.png" alt="屏幕截图 2024-10-24 181223"></p><p>如何处理节点的分裂：转换那个分裂的节点所连接的线的性质（在图示中，就是改变线的颜色），更准确地说，分裂的主要操作是将<strong>中间节点上提</strong>，并且将子节点和中间节点的红色链接进行调整，可能还需要旋转：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181234.png" alt="屏幕截图 2024-10-24 181234"></p><p>课本对次的总结</p><ul><li>When inserting: Use a <strong>red link</strong>. Insert in the same way as inserting into a BST.</li><li>If there is a right-leaning “3-node”, we have a <strong>Left Leaning Violation</strong>.<ul><li><strong>Rotate left</strong> the appropriate node to fix.</li></ul></li><li>If there are two consecutive left links, we have an <strong>Incorrect 4 Node Violation</strong>.<ul><li><strong>Rotate right</strong> the appropriate node to fix.</li></ul></li><li>If there are any nodes with two red children, we have a <strong>Temporary 4 Node</strong>.<ul><li><strong>Color flip</strong> the node to emulate the split operation.</li></ul></li></ul><h3 id="Runtime-Analyse"><a href="#Runtime-Analyse" class="headerlink" title="Runtime Analyse"></a>Runtime Analyse</h3><p>因为红黑左倾树与B-Tree一一对应（<strong>每一个</strong> 2-3树都可以唯一地表示为一棵左倾红黑树。反之亦然）,所以时间复杂度也是 <em>l<strong>o</strong>g</em>(<em>N</em>) 。</p><p>Here’s the abstracted code for insertion into a LLRB:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, Key key, Value val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; h.right = put(h.right, key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span>              &#123; h.val   = val;                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><h3 id="Introduction-to-Hashing-Data-indexed-Arrays"><a href="#Introduction-to-Hashing-Data-indexed-Arrays" class="headerlink" title="Introduction to Hashing: Data indexed Arrays"></a>Introduction to Hashing: Data indexed Arrays</h3><p>目前，我们搭建了许多数据结构来存放数据，但我们不是很满意，一是因为时间复杂度不是<code>O(1)</code>, 二是因为之前的数据结构都是需要可比较的数据的。所以，我们要搭建一个可以容纳所有事物以及时间复杂度完美的数据结构。</p><p>说到时间复杂度为<code>O(1)</code>,就会想到数组，无论是<code>add()</code>还是<code>contain()</code>，时间复杂度都为常数时间。</p><p>搭建一个容纳所有数字的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码有两大致命缺点：</p><ul><li>太浪费内存空间：如果只插入一两个数据，剩下的空间无处可用。</li><li>只适用于整数类型</li></ul><h3 id="Hash-Code"><a href="#Hash-Code" class="headerlink" title="Hash Code"></a>Hash Code</h3><p>Hash可以存储所有类型，但数组所含类型要一致，我们只能忍痛割爱，选择整数了，为了把字符转换为数字，我们专门写一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory-Inefficiency-in-Hash-Codes"><a href="#Memory-Inefficiency-in-Hash-Codes" class="headerlink" title="Memory Inefficiency in Hash Codes"></a>Memory Inefficiency in Hash Codes</h3><p>我们可以使用一个单独存放每个哈希值的数组。也就是说，数组中的每个索引都代表一个唯一的哈希值。如果我们的指标很小并且接近于零，这个方法很有效。但是我们想要存放hash值范围可能只有很小的一部分，我们也可能需要一个十分长的数组。</p><p>相反，我们将稍微修改我们的索引策略。假设我们只想支持长度为10的数组，以避免分配过多的内存。我们如何将一个可能是数百万或数十亿的数字转换为0到9（包括0到9）之间的值？</p><h3 id="Wrapping"><a href="#Wrapping" class="headerlink" title="Wrapping!"></a>Wrapping!</h3><p>我们可以使用<code>floorMod()</code>来实现我们想要的数组大小，即使超出数组大小，这个函数也可以将他转换为我们数组允许的大小。</p><p>原理：floorMod函数将在正确计算负整数的情况下执行取模操作：<code>Math.floorMod(-3, 10) = 7 --------&gt; -3 = -1 * 10 + 7</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floorMod(key.hashCode(), array.length)</span><br></pre></td></tr></table></figure><p>这就像规定了水桶的数量，将数据放在指定的水桶，我们预先只规定了桶的数量与容量极限，刚开始都只是空桶，我们按游戏规则往里面放东西，放多少东西是我们自己决定的（放多少有多少），相比之前数组一开始就把容量固定好了，更加节约空间，但如果每个桶都到达极限，我们需要再增添一些桶。但这个极限怎么规定呢？我们会定义一个 load factor （负载因子）（N&#x2F;M，其中N是表中元素的数量，M是桶的数量），超过某个常数就会添加桶的数目。</p><p>字符&#x2F;数字等要存放的数据的默认哈希值是它们的地址值（每一次运行都是随机的）.</p><h3 id="Comparing-Data-Structure-Run-Times"><a href="#Comparing-Data-Structure-Run-Times" class="headerlink" title="Comparing Data Structure Run Times!"></a>Comparing Data Structure Run Times!</h3><table><thead><tr><th align="left"></th><th align="left">contains(x)</th><th align="left">add(x)</th></tr></thead><tbody><tr><td align="left">Bushy BSTs</td><td align="left">Θ(log N)</td><td align="left">Θ(log N)</td></tr><tr><td align="left">Separate Chaining Hash Table with NO resizing</td><td align="left">Θ(N)</td><td align="left">Θ(N)</td></tr><tr><td align="left">Separate Chaining Hash Table with resizing</td><td align="left">Θ(1)</td><td align="left">Θ(1)</td></tr></tbody></table><p><code>floorMod()</code>不需要在<code>hashCode()</code>中执行，可以放在hashtable中，<code>hashCode()</code>返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不使用默认哈希值，在查找对应的元素，由于地址是随机的，查找元素的地址也是随机的，两个元素取模可能结果不一致。要保证<code>equal()</code>和<code>contain()</code>哈希值规定一致。</p><p>原话：<strong>Basic rule (also definition of deterministic property of a valid hashcode):</strong> If two objects are equal, they <strong>must</strong> have the same hash code so the hash table can find it.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   ...  <span class="keyword">return</span> <span class="built_in">this</span>.num == otherCn.num; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutable-vs-Immutable-Types"><a href="#Mutable-vs-Immutable-Types" class="headerlink" title="Mutable vs. Immutable Types"></a>Mutable vs. Immutable Types</h3><p>可变性：可以外部改变</p><p>不变性：不可改变</p><ul><li><p><code>final</code> ：作为修饰词定义变量不可改变</p></li><li><p><code>private</code>: 作为修饰词定义变量不可改变（限制访问）</p><p>注意：对于数组里的元素不起效，上面的两个只能保证定义的那个变量不可改变，保证数组指向内存仍然是之前的，内部的元素不在管辖之内</p><p>为了让数组彻底不可改变，可以定义一个类进行封装。</p></li></ul><h2 id="Heaps-and-Priority-Quenes"><a href="#Heaps-and-Priority-Quenes" class="headerlink" title="Heaps and Priority Quenes"></a>Heaps and Priority Quenes</h2><h3 id="Priority-Quenes"><a href="#Priority-Quenes" class="headerlink" title="Priority Quenes"></a>Priority Quenes</h3><p>优先队列作为一个数据结构，大致结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** (Min) Priority Queue: Allowing tracking and removal of </span></span><br><span class="line"><span class="comment">  * the smallest item in a priority queue. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Priority Queue is an Abstract Data Type that optimizes for handling minimum or maximum elements.</li><li>There can be space&#x2F;memory benefits to using this specialized data structure.</li><li>Implementations for ADTs that we currently know don’t give us efficient runtimes for PQ operations.<ul><li>A binary search tree is the most efficient among the other structures</li></ul></li></ul><h3 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h3><p>特性：</p><ul><li>Min-heap: 节点始终小3于等于它的两个子节点</li><li>Complete: 节点尽可能地靠左。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20153855.png" alt="屏幕截图 2024-10-29 153855"></p><p>一些操作：</p><ul><li>add: 暂时添加到底部，如果child &lt; parent，则交换节点</li><li>getSmallest：根节点</li><li>removeSmalleat；让底部的节点代替根节点，如果parent  &gt; child，则交换节点</li></ul><p>实现方式：</p><ul><li><p><strong>Tree1A</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1A</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1A left;</span><br><span class="line">  Tree1A middle;</span><br><span class="line">  Tree1A right;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160422.png" alt="屏幕截图 2024-10-29 160422"></p></li><li><p><strong>Tree1B</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1B</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1B[] children;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160622.png" alt="屏幕截图 2024-10-29 160622"></p></li><li><p><strong>TreeC</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1C favoredChild;</span><br><span class="line">  Tree1C sibling;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160756.png" alt="屏幕截图 2024-10-29 160756"></p></li></ul><p>搭建代码：</p><p>效仿<code>Disjoint Set</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  <span class="type">int</span>[] parents;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20161421.png" alt="屏幕截图 2024-10-29 161421"></p><p>但我们发现<code>parents</code>似乎是多余的，因为keys与树的结构一一对应（都是左边节点序号再右边节点序号再左边节点的左子节点…以此往复，对应的数组也只是同样节点的子节点序号一致）</p><p>所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeC</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20162015.png" alt="屏幕截图 2024-10-29 162015"></p><p><strong>swim</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys[parent(k)] ≻ keys[k]) &#123;</span><br><span class="line">       swap(k, parent(k));</span><br><span class="line">       swim(parent(k));              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应：</p><ul><li><code>leftChild(k)</code>&#x3D; k∗2 +1</li><li><code>rightChild(k)</code>&#x3D; k∗2+2</li><li><code>parent(k)</code>&#x3D; （k-1）&#x2F;2</li></ul><h3 id="Comparing-to-alternative-implementations"><a href="#Comparing-to-alternative-implementations" class="headerlink" title="Comparing to alternative implementations"></a>Comparing to alternative implementations</h3><table><thead><tr><th align="left">Methods</th><th align="left">Ordered Array</th><th align="left">Bushy BST</th><th align="left">Hash Table</th><th align="left">Heap</th></tr></thead><tbody><tr><td align="left"><code>add</code></td><td align="left">Θ(N)Θ(<em>N</em>)</td><td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td><td align="left">Θ(1)Θ(1)</td><td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td></tr><tr><td align="left"><code>getSmallest</code></td><td align="left">Θ(1)Θ(1)</td><td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td><td align="left">Θ(N)Θ(<em>N</em>)</td><td align="left">Θ(1)Θ(1)</td></tr><tr><td align="left"><code>removeSmallest</code></td><td align="left">Θ(N)Θ(<em>N</em>)</td><td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td><td align="left">Θ(N)Θ(<em>N</em>)</td><td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td></tr></tbody></table><h3 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a><strong>完整代码如下：</strong></h3><p>以最小堆为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heaps</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heaps</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        heap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[i].compareTo(heap[parent(i)]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(i, parent(i));</span><br><span class="line">            i = parent(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == heap.length - <span class="number">1</span>) &#123; <span class="comment">// 修改了越界检查</span></span><br><span class="line">            <span class="built_in">this</span>.resize(heap.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[size] = t;</span><br><span class="line">        swim(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        T[] newHeap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[newCapacity + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(heap, <span class="number">0</span>, newHeap, <span class="number">0</span>, size);</span><br><span class="line">        heap = newHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(heap[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left(k) &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left(k);</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; size &amp;&amp; heap[j + <span class="number">1</span>].compareTo(heap[j]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap[k].compareTo(heap[j]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        sink(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tree-Traversals-and-Graphs"><a href="#Tree-Traversals-and-Graphs" class="headerlink" title="Tree Traversals and Graphs"></a>Tree Traversals and Graphs</h2><h3 id="Tree-Traversal"><a href="#Tree-Traversal" class="headerlink" title="Tree Traversal"></a>Tree Traversal</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-30%20215713.png" alt="屏幕截图 2024-10-30 215713"></p><ul><li><p>Level Order Traversal:一层层从左向右遍历 （D B F A C E G）</p></li><li><p>Pre-order Traversal: 优先结点最先（D B A C  F E G）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    print(x.key)</span><br><span class="line">    preOrder(x.left)</span><br><span class="line">    preOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In-order Traversal: 优先结点其次（A B C D E F G）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    inOrder(x.left)</span><br><span class="line">    print(x.key)</span><br><span class="line">    inOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Post-order Traversal：优先结点最后（A C B E G F D）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    postOrder(x.left)</span><br><span class="line">    postOrder(x.right)</span><br><span class="line">    print(x.key)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表-树-图"><a href="#表-树-图" class="headerlink" title="表&amp;&amp;树&amp;&amp;图"></a><strong>表&amp;&amp;树&amp;&amp;图</strong></h3><p>表：</p><ul><li>结点之间路径唯一</li><li>子结点唯一</li></ul><p>树：</p><ul><li>结点之间路径唯一</li><li>子节点不唯一</li></ul><p>图：</p><ul><li>结点之间路径不唯一</li><li>子节点不唯一</li></ul><h3 id="Simple-Graphs-VS-multigraphs"><a href="#Simple-Graphs-VS-multigraphs" class="headerlink" title="Simple Graphs VS multigraphs"></a>Simple Graphs <strong>VS</strong> <em>multigraphs</em></h3><p>复杂图相比简单图会有自环（一个节点到自身的边）和重边（两个节点之间的多条边），甚至有更复杂的结构。</p><h2 id="Graph-Traversals-and-implementations"><a href="#Graph-Traversals-and-implementations" class="headerlink" title="Graph Traversals and implementations"></a>Graph Traversals and implementations</h2><h2 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h2><h2 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h2><h2 id="Prefix-Operations-and-Tries"><a href="#Prefix-Operations-and-Tries" class="headerlink" title="Prefix Operations and Tries"></a>Prefix Operations and Tries</h2><h2 id="Sorting-–-排序方法"><a href="#Sorting-–-排序方法" class="headerlink" title="Sorting – 排序方法"></a>Sorting – 排序方法</h2><p>这节的任务列表如下：</p><ul><li><input disabled="" type="checkbox"> Section Sort</li><li><input disabled="" type="checkbox"> Heap Sort</li></ul><h3 id="Selection-Sort-–-选择排序"><a href="#Selection-Sort-–-选择排序" class="headerlink" title="Selection Sort – 选择排序"></a>Selection Sort – 选择排序</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-18%20201012.png" alt="屏幕截图 2024-10-18 201012"></p><p><em><strong>选择排序有两种实现方式：</strong></em></p><ol><li>找到最小的元素，把它放在最左边，然后在剩余的元素中重复这个操作。</li><li>找到最大的元素，把它放在最右边，然后在剩余的元素中重复这个操作。</li></ol><h4 id="Section-Runtime"><a href="#Section-Runtime" class="headerlink" title="Section Runtime"></a>Section Runtime</h4><p>   <strong>时间复杂度：O(N^2);</strong></p><p>   选择排序每次操作都在找最小的值，还记得堆(heap)和优先队列(priority)吗？堆十分擅                      长告诉我们最小的元素。</p><h3 id="Heap-Sort-–-堆排序"><a href="#Heap-Sort-–-堆排序" class="headerlink" title="Heap Sort – 堆排序"></a>Heap Sort – 堆排序</h3><h4 id="Naive-heap-sort"><a href="#Naive-heap-sort" class="headerlink" title="Naive heap sort"></a>Naive heap sort</h4><ul><li><p>Insert all items into a max heap, and discard input array. Create output array.</p></li><li><p>Repeated N times:</p><ul><li><p>Delete largest item from the max heap.</p></li><li><p>Put largest item at the end of the unused part of the output array.</p><p> 这一步就是将堆的最大值放在大小为size的数组最后可放的位置，然后移除最大值，直到第一个元素为最小。</p></li></ul><p>这边有一个问题：为什么不用最小堆，这个问题我们先不讨论，先把它放在<strong>分支任务</strong>里。</p><p>分支任务如下：</p><ul><li><input disabled="" type="checkbox"> 堆排序为什么用最大堆而不是最小堆</li></ul></li></ul><p>总运行时间有两个步骤：</p><ul><li><p>堆排列的时间：O(N logN).</p></li><li><p>删除元素的总时间：O(N(需要删除的元素个数) * logN(每次删除的时间)) &#x3D; O(N logN).</p><p> 最后结合两个的时间，得到的<strong>时间复杂度</strong>为O(N logN).</p></li></ul><p>我们再来看看空间复杂度（内存使用情况）：创建了一个大小为N的数组来存放堆，又创建一个大小为N的数组来存放排好序的元素。</p><p>所以，内存使用情况为O(N).</p><ul><li><input checked="" disabled="" type="checkbox"> Section Sort</li></ul><h4 id="Heapification"><a href="#Heapification" class="headerlink" title="Heapification"></a>Heapification</h4><p>我们不想创建额外的数组，可以将数组堆化，但这个堆并不是有效的最大堆。</p><ul><li>Bottom-up heapify input array:<ul><li>Sink nodes in reverse level order: sink(k)</li><li>After sinking, guarantee that rooted at position k is a heap.</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-18%20210729.png" alt="屏幕截图 2024-10-18 210729"></p><p>这一步是从堆的底部开始，当子节点比节点大就交换位置。</p><p>现在让我们来解决为什么使用最大堆而不是最小堆（视频位置Lecture 24 –  44：10）：</p><p>如果堆（heap）正在消耗元素以至于它的后面的元素开始变得未使用，而输出数组正在从后面填充元素，以至于它们未被使用，它们处于一种动态平衡的状况，这种情况下不需要创建一个新数组。</p><ul><li><input checked="" disabled="" type="checkbox"> 堆排序为什么用最大堆而不是最小堆</li></ul><h4 id="Heapsort-Runtime"><a href="#Heapsort-Runtime" class="headerlink" title="Heapsort Runtime"></a>Heapsort Runtime</h4><p>总运行时间分为两个步骤：</p><ul><li>自底而上的堆化过程的时间：最坏的情况下，我们要堆化(堆化时间为logN)所有元素(N个)，时间为O(N logN)</li><li>删除元素：O(N(元素个数) * (删除一个元素的时间)logN) &#x3D; O(N logN)</li><li><input checked="" disabled="" type="checkbox"> Heap Sort</li></ul><h3 id="Mergesort"><a href="#Mergesort" class="headerlink" title="Mergesort"></a>Mergesort</h3><p>merge —- 合并 —–&gt; 分组排序<br>对于一大堆无序的数据，一次性整理有序是十分困难的，时间复杂度还为O($N^2$),但我们可以将这一大堆数据一分为二在进行排序，虽然这样单独一个小组的时间复杂度仍然是O($N^2$)（比未分组之前的O($N^2$)的快），但由于合并时时间复杂度为O(1),所以已经快很多了。我们已经执行过一次一分为二了，为什么不做到底，直到不能再分，此时我们甚至不需要再使用选择排序了，因为一个数据就是有序的。<br><strong>归并排序</strong>的本质：</p><ul><li>如果列表大小为 1，则返回。否则：</li><li>对左半部分进行合并排序</li><li>合并排序右半部分</li><li>合并结果<br><strong>运行时间：</strong> $Nlog_{2}{X}$<br>具体计算过程：<br>$$<br>C(N) &#x3D; \left{\begin{matrix}<br>      1&amp;  &amp;N&#x3D;1 \<br>      2C(N&#x2F;2)+N&amp;  &amp;N&gt;&#x3D;2<br> \end{matrix}\right.</li></ul><p>$$<br>具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void mergeSort(int[] array, int left, int right) &#123;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            mergeSort(array, left, mid);</span><br><span class="line">            mergeSort(array, mid + 1, right);</span><br><span class="line">            merge(array, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void merge(int[] array, int left, int mid, int right) &#123;</span><br><span class="line">        int n1 = mid - left + 1;</span><br><span class="line">        int n2 = right - mid;</span><br><span class="line"></span><br><span class="line">        int[] L = new int[n1];</span><br><span class="line">        int[] R = new int[n2];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n1; i++)</span><br><span class="line">            L[i] = array[left + i];</span><br><span class="line">        for (int j = 0; j &lt; n2; j++)</span><br><span class="line">            R[j] = array[mid + 1 + j];</span><br><span class="line"></span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int k = left;</span><br><span class="line">        while (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            if (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                array[k] = L[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[k] = R[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt; n1) &#123;</span><br><span class="line">            array[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (j &lt; n2) &#123;</span><br><span class="line">            array[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;12, 11, 13, 5, 6, 7&#125;;</span><br><span class="line">        mergeSort(array, 0, array.length - 1);</span><br><span class="line">        for (int num : array) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><h3 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数的旅程</title>
      <link href="/water.github.io/2024/10/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%97%85%E7%A8%8B/"/>
      <url>/water.github.io/2024/10/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数的旅途"><a href="#线性代数的旅途" class="headerlink" title="*线性代数的旅途"></a>*线性代数的旅途</h1><h2 id="旅途的第一站（章）-–-线性代数的本质"><a href="#旅途的第一站（章）-–-线性代数的本质" class="headerlink" title="旅途的第一站（章） – 线性代数的本质"></a>旅途的第一站（章） – 线性代数的本质</h2><p>哔哩哔哩上《线性代数的本质》的一些笔记</p><p>原视频链接：<a href="https://www.bilibili.com/video/BV1ys411472E?p=2&vd_source=52cc25d7b185f522bb256efa0f7cca48">01 - 向量究竟是什么？_哔哩哔哩_bilibili</a></p><p>“BV1ys411472E”</p><h3 id="第一节-—-向量究竟是什么？"><a href="#第一节-—-向量究竟是什么？" class="headerlink" title="第一节 — 向量究竟是什么？"></a>第一节 — 向量究竟是什么？</h3><p>从物理的角度来看，向量是空间里的箭头，决定一个向量的是它的长度和它所指的方向</p><p>从计算机的角度来看，向量是有序的数字列表，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-08%20182113.png" alt="屏幕截图 2024-10-08 182113"></p><p>物理的角度与计算机的区别在于：</p><p>物理方面注重空间上的描述</p><p>计算机方面注重数据的有序</p><p>而数学需要去概括且结合这两种观点：向量可以是任何东西，只要保证两个向量相加以及向量相乘是有意义的即可。（向量加法与向量乘法贯彻线性代数始终，十分重要）</p><p>几何方面（对应物理角度）：考虑一个箭头落在某个坐标系中，并且箭头起点位于原点，与物理角度不同，物理箭头起点可以落在空间任何位置</p><p>代数方面（对应计算机方面）：用以下方式来表示向量（下图所示）</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-08%20184207.png" alt="屏幕截图 2024-10-08 184207"></p><p>且向量与坐标以如下形式区分开</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-08%20184325.png" alt="屏幕截图 2024-10-08 184325"></p><p>向量加法 –&gt; 首尾相加，不做过多描述，图解如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-08%20184806.png" alt="屏幕截图 2024-10-08 184806"></p><p>向量相乘 –&gt; 向量的缩放，缩放的系数称为标量，图解如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-08%20184943.png" alt="屏幕截图 2024-10-08 184943"></p><h3 id="第二节-—-线性组合-张成的空间-基"><a href="#第二节-—-线性组合-张成的空间-基" class="headerlink" title="第二节 — 线性组合&amp;&amp;张成的空间&amp;&amp;基"></a>第二节 — 线性组合&amp;&amp;张成的空间&amp;&amp;基</h3><p>怎么用有限的向量来表示无限的空间呢？（以下那二维空间举例 –&gt; x-y）</p><p>在了解了向量加法与向量数乘，我们可以发现不重合的两个向量似乎可以做到！</p><p>这两个特殊的向量被称为坐标系的基（basis of a coordinste system）</p><p>在x-y坐标系上最特殊的莫过于（1，0）与（0， 1）了。</p><p>两个数乘向量的和被称为这两个向量的线性组合。</p><p>线性这个词哪里来？有一个不是它的根源的说法 – 固定其中一个标量，让其中一个标量自由变化，所产生的向量终点会描出一条直线。</p><p>如果你让两个标量同时自由变化，考虑所有可能得到的向量，有3种情况：</p><p>1&gt; 当两个向量不重合或不在一条直线上，线性组合可以到达平面中的任意一点‘</p><p>2&gt; 倘若恰好在一条直线上，所产生的终点被限制在一条过原点的直线上</p><p>3&gt;更极端的情况，两个向量都是零向量，那无论如何线性组合，最终的结果都只会在原点</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20221517.png" alt="屏幕截图 2024-10-09 221517"></p><p>所有可以表示为给定向量线性组合的向量的集合，被称为<strong>给定向量张成的空间</strong>（the span of those two vectors)</p><p>当空间向量多到看不清时，可以仅仅保留终点。</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20222059.png" alt="屏幕截图 2024-10-09 222059"></p><p>当有一个向量对张成空间没有贡献，我们称为“线性相关”。</p><p>若没有，我们称为“线性无关”。</p><h3 id="第三节-—-矩阵与线性变换（Linear-transformations）"><a href="#第三节-—-矩阵与线性变换（Linear-transformations）" class="headerlink" title="第三节 — 矩阵与线性变换（Linear transformations）"></a>第三节 — 矩阵与线性变换（Linear transformations）</h3><p>重点：线性变换的概念以及它和矩阵的关系</p><p>本节如标题所示，会以线性变换为中心进行讨论， 主要包括：这些变换在二维空间中长什么样，以及它们如何与矩阵向量乘法相关联。</p><p>“变换”实际上是函数的一种花哨的说法。那为什么不直接使用函数这个名称，叫线性函数呢？</p><p>后面我们将在接下来的操作下的过程中体会这个词的“可视化”。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20181331.png" alt="屏幕截图 2024-10-11 181331"></p><p>用图将整个坐标系进行变换，直接用向量箭头画面会显得很杂乱，所以我们用上一节的思想—只保留向量的终点。</p><p>那线性又是什么意思，一个变换具有以下两个性质：</p><p>1&gt; 直线在变换后还是直线</p><p>2&gt; 原点位置不变</p><p>话句话说：保持网格状平行且等距分布。</p><p>怎么知道变换后的向量？</p><p>只需抓住张成这个空间的基即可，变换不会改变前后的线性组合</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20182558.png" alt="屏幕截图 2024-10-11 182558"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20182643.png" alt="屏幕截图 2024-10-11 182643"></p><p>或者逆时针旋转90度</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20182736.png" alt="屏幕截图 2024-10-11 182736"></p><p>有一个特殊的变换叫作“剪切”，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20183012.png" alt="屏幕截图 2024-10-11 183012"></p><p>如果变化后的基是线性相关的，那么称作“列（向量）线性相关” </p><h3 id="第四节-—-矩阵乘法与线性变换复合"><a href="#第四节-—-矩阵乘法与线性变换复合" class="headerlink" title="第四节 — 矩阵乘法与线性变换复合"></a>第四节 — 矩阵乘法与线性变换复合</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-14%20203356.png" alt="屏幕截图 2024-10-14 203356"></p><p>线性变换可以叠加，可以先旋转后剪切，称为<strong>复合变换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-14%20203823.png" alt="屏幕截图 2024-10-14 203823"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-14%20204158.png" alt="屏幕截图 2024-10-14 204158"></p><p>M2可以看作坐标系先逆时针旋转，在左右翻转。（给2乘上-1，再乘回来的过程，当向量旋转大于180度，就可以乘上-1来拆分过程）</p><p>M1与M2相结合的过程，可以先完成M1，再完成M2（M2作用对象是最原本的x-y坐标系，可以将基在经过M1的作用后看作原本x-y中的普通向量，在跟随新x-y一起旋转），就像过年那个吃年夜饭的旋转圆盘，假设有两个，你先转最上面一个，再旋转第二个，或者地球，太阳以及黑洞（银河系中心），地球在围绕太阳转的同时，也跟随太阳围绕银河系中心转，更多Mi,只是参考系的叠加罢了。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-14%20205816.png" alt="屏幕截图 2024-10-14 205816"></p><p>变换后的基如上图的(e,g)和(f,h),作为普通向量分别经过M2的洗礼罢了。</p><p>那M1 M2 ?&#x3D; M2 M1呢？ </p><p>答案是不等于。</p><p>那么（A B）C ?&#x3D; A (B C)呢？</p><p>答案是相等。</p><p>为什么呢</p><p>前者好比本来是先穿袜子再穿鞋，不能先穿鞋子在穿袜子。（M1和M2始终都是对（1，0）和（0，1）做变换，不是直接对变换后的基做变换，所以顺序不能改变）。</p><p>后者好比是先拿鞋在穿袜子最后穿鞋，括号不影响先后顺序。</p><p>由此可见，线性变换有结合律，但没有交换律。</p><h3 id="第五节-—-行列式"><a href="#第五节-—-行列式" class="headerlink" title="第五节 — 行列式"></a>第五节 — 行列式</h3><p>你知道怎么计算行列式吗，你知道结果代表什么吗？</p><p>让我们通过这节课，探索其中的奥妙吧！！</p><p>你可能发现线性变换对空间或多或少会有拉伸挤压，但我们不知道具体拉伸(挤压)了多少，那么是否可以量化这个拉伸或挤压程度呢？行列式的概念横空出世，来解决这个问题！！</p><p>怎么比较前后变化了多少呢？总要有一个参照物吧。所以我们以基所组成的有规律的图形来定义。不同维度图形不同，二维就是一个平行四边形的面积，三维就是体积…（1x1，1x1x1…）</p><p>有一个特例，就是行列式为零的时候，他代表空间被压缩到更小的维度上。</p><p>当然，你有时候会发现行列式的值为负，这代表将空间翻转了（这与前面判断线性变换是否使坐标系左右翻转有关）,当然这是二维的情况，三维需要用右手定则（视频更加直观）</p><p>至于行列式为负的情况，是很自然的，当基重合时（行列式为零），继续运动下去，为零不是很正常的吗？</p><p>给出行列式的公式以及图解：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20191415.png" alt="屏幕截图 2024-10-15 191415"></p><h3 id="第六节-—-逆矩阵-列空间-零空间"><a href="#第六节-—-逆矩阵-列空间-零空间" class="headerlink" title="第六节 — 逆矩阵&amp;&amp;列空间&amp;&amp;零空间"></a>第六节 — 逆矩阵&amp;&amp;列空间&amp;&amp;零空间</h3><p>线性代数的应用很广泛，在于它能帮助我们求解特定的方程组。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20191952.png" alt="屏幕截图 2024-10-15 191952"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20192048.png" alt="屏幕截图 2024-10-15 192048"><br>$$<br>A x &#x3D;v<br>$$<br>通常大多数向量我们用了线性变换，可以通过逆向操作获得原来的向量。我们称这个逆向操作为A的逆.</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20192842.png" alt="屏幕截图 2024-10-15 192842"></p><p>这个变换被称为“恒等变换”。</p><p>我们可以利用这个行质求解向量方程。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20192952.png" alt="屏幕截图 2024-10-15 192952"></p><p>刚才所说的情况适用于大多数线性变换，对于变换降低了维度，也就是行列式为零的情况不适用，这种情况A没有逆（因为维度降低了，是无法靠线性变换回去的），拿二维举例，二维压缩成一条线，你不能指望解压缩一条线获得二维空间的所有向量。这样会要求已经重合唯一的向量变换为无数向量，也就是映射多个向量，但线性变换在前面说过，相当于函数，只能将一个输入变换为一个输出，所以这是不现实的。（行列式为零不代表没有解）。</p><p>为了表示线性变换的结果，专门有一个术语来表示线性变换后的维度—–“<strong>秩</strong>”</p><p>对于一个空间中的所有向量经过线性变换输出的集合称为“<strong>列空间</strong>”（<strong>Colum space</strong> 0f “A”）</p><p>”列“的含义，线性变换（矩阵的列）告诉我们基向量变换后的位置。</p><p>如前面所说，这些变换后的基向量张成的空间就是所有可能的变换结果。</p><p>换句话说，列空间就是矩阵的列所张成的空间。</p><p>秩的一个定义就是列空间的维数。</p><p>当秩与列数相等，称为”<strong>满秩</strong>“</p><p>零向量必然在列空间中，这是因为线性变换的特性（原点不动）。</p><p>对于非满秩矩阵来说，会有一堆向量在变换后成为零向量。这些变换后落在远点的向量的集合被称为<strong>零空间（Null space）或核（Kernel）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20195937.png" alt="屏幕截图 2024-10-15 195937"></p><h3 id="第七节-—-点积与对偶性"><a href="#第七节-—-点积与对偶性" class="headerlink" title="第七节 — 点积与对偶性"></a>第七节 — 点积与对偶性</h3><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20142503.png" alt="屏幕截图 2024-10-16 142503"></p><p>点积，两个维数相同的向量坐标一一对应相乘相加。代数上就是这样。</p><p>现在我们来看它的几何解释（如下图）：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20142835.png" alt="屏幕截图 2024-10-16 142835"></p><p>这是结果为正的情况，再来看结果为负的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20142920.png" alt="屏幕截图 2024-10-16 142920"></p><p>上述的表达式还可以表示成v的投影长度乘以w的长度，没错，点积与顺序无关。下面我们来证明为什么与顺序无关。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20143434.png" alt="屏幕截图 2024-10-16 143434"></p><p>这显然与对称无关，我们现在破坏这个对称性。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20143650.png" alt="屏幕截图 2024-10-16 143650"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20143711.png" alt="屏幕截图 2024-10-16 143711"></p><p>话又说回来，为什么点积与投影有关？——<strong>“对偶性</strong>”</p><p>不过在讨论这个之前，先要了解多维空间到一维空间（数轴）的线性变换，</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20191738.png" alt="屏幕截图 2024-10-16 191738"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20191752.png" alt="屏幕截图 2024-10-16 191752"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20191856.png" alt="屏幕截图 2024-10-16 191856"></p><p>如果这些点没有等距分布，那么这个变换就不是线性的。这些线性变换完全由他对基的变换决定。但是这一次，这些基向量只落在一个数上，所以当我们将他们变换的位置记录为矩阵的列时，矩阵的每列只是一个单独的数。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20192444.png" alt="屏幕截图 2024-10-16 192444"></p><p>接下来，我们用一个例子来了解它对向量的含义。</p><p>假如有一个线性变换，他将基(i,j)分别变换为1和-2，要跟踪一个向量，视频中举了（4，3），当在计算向量变换后的结果，从数值角度进行计算时，他就是矩阵向量乘法。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20193208.png" alt="屏幕截图 2024-10-16 193208"></p><p>这变换矩阵不像一个躺下的向量吗？你想在可以将矩阵立直，从而得到与之相关的向量，或者将向量放倒，从而得到与之相关的矩阵。</p><p>这种联系在几何上是什么意思？让我们来看一个例子，我们将一个数轴经过原点斜放在空间中。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20193906.png" alt="屏幕截图 2024-10-16 193906"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20193936.png" alt="屏幕截图 2024-10-16 193936"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20194042.png" alt="屏幕截图 2024-10-16 194042"></p><p>实际上我们定义了一个从二维向量到数的一个函数，重要的是这个函数是线性的，实线上等距分布的店在投影在数轴上仍然等距分布，</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20194447.png" alt="屏幕截图 2024-10-16 194447"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20194552.png"></p><p>怎么获得一个变换矩阵使二维向量转换为一个数呢？我们应该抓住数轴上的向量反推，因为这些向量既在数轴上，又在二维空间中，它对数轴的投影就是它的模（向量长度），为了方便，我们用单位向量u来举例，用之前对称轴的方法来计算基底会落在数组的那个位置，以基底i为例，i变换落在数轴上的位置等于u的横向量，同理，j变换的位置等于u的纵向量。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20200014.png" alt="屏幕截图 2024-10-16 200014"></p><p>这样我们就可以使任意函数都落在数轴上了。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20200602.png" alt="屏幕截图 2024-10-16 200602"></p><p>这也是为什么将点积理解为将向量投影到单位向量所在的直线上所得到的投影长度</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20200914.png" alt="屏幕截图 2024-10-16 200914"></p><p>非单位向量也同理。非单位向量无非是将单位向量放大或缩小了，相对应的基也跟着变化就可以了，之前单位向量投影所得到的值也要乘以相应的倍数。</p><p>当你看到一个空间经过线性变换输出的结果为一维数组，就要想到它与空间中的唯一向量与之相关。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-16%20202140.png"></p><p>总结，表面上看，点积是理解投影的有利几何工具，并且方便检验两个向量的指向是否相同，更进一步，两个向量点乘，就是将其中的一个向量转换为线性变换。</p><h3 id="第八节-—-叉积的标准介绍"><a href="#第八节-—-叉积的标准介绍" class="headerlink" title="第八节 — 叉积的标准介绍"></a>第八节 — 叉积的标准介绍</h3><p>假设平面分别有两个向量围成一个平面四边形 </p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20142213.png" alt="屏幕截图 2024-10-17 142213"></p><p>并且v在w的右边，值为正，反之为负。</p><p>如何记住正负呢？基向量的顺序就是定向的基础。（涉及翻转，x在y右边，没翻转）</p><p>可以通过行列式计算面积（值的正负正是前面讨论过的翻转的问题），</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20142814.png" alt="屏幕截图 2024-10-17 142814"></p><p>为什么可以这样做呢？这是因为以这两个向量为列的行列式作为变换矩阵将基转换为这两个向量，所计算的面积与我们要求的面积在数值上相同。</p><p>v与w位置关系是垂直或接近于垂直，与他们指向接近时叉积更大。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20143938.png" alt="屏幕截图 2024-10-17 143938"></p><p>从中也可以发现行列式的性质。</p><p>但以上讨论的还不是叉积，真正的叉积是通过两个三维向量生成一个新的三维向量。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20144249.png" alt="屏幕截图 2024-10-17 144249"></p><p>判断生成的向量用右手定则；</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20144406.png" alt="屏幕截图 2024-10-17 144406"></p><p>计算该向量的公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20144513.png" alt="屏幕截图 2024-10-17 144513"></p><p>当这公式怎么来的？先给一张图，具体过程的之后再详细讨论。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-17%20144908.png" alt="屏幕截图 2024-10-17 144908"></p><p>以线性角度看叉积，可以利用一个任意的线性变换使三维向量变成3x3的行列式（线性变换又可以找到对偶向量），使其成为两个三维向量的点积等于行列式的值。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-20%20182253.png" alt="屏幕截图 2024-10-20 182253"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-20%20182305.png" alt="屏幕截图 2024-10-20 182305"></p><p>3x3的行列式的值相当于平行六面体的体积，而两个三维向量的点积相当于<code>[x, y, z]</code>的投影乘以垂直于v和w所组成的面积的向量.（这也是为什么混合乘积时，先算叉积再算点积的原因）,该向量数值上等于v和w所组成的面积，方向与<code>[x, y, z]</code>有关（右手定则）。</p><p>具体思路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-20%20183402.png" alt="屏幕截图 2024-10-20 183402"></p><h3 id="第九节-—-基变换"><a href="#第九节-—-基变换" class="headerlink" title="第九节 — 基变换"></a>第九节 — 基变换</h3><p>只要一组向量的缩放可以表示空间里的所有向量就被称为基，这是我们熟知的事情。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20212526.png" alt="屏幕截图 2024-10-22 212526"></p><p>假设基的选定不同，向量的表示也会不同。当我们知道一组基与一个向量基于这组基的表示方式，怎么用标准基来表示这个向量？</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20214515.png" alt="屏幕截图 2024-10-22 214515"></p><p>我们当然可以直接使用基乘以那组数来获取标准基的向量！</p><p>将另一组基作为线性变换乘以一个向量相当于将这个向量从另一组基的表示转换为标准基的表示。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20215422.png" alt="屏幕截图 2024-10-22 215422"></p><p>而对于将标准基的表示转换为另一组基的表示就是乘以它的逆。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20215523.png"></p><p>线性变换复合也是如此，我们想要哪个向量作为基，就乘上它的逆。（这与之前的线性变换复合(M1 X M2 )始终将M1变换后仍看作是以标准基为准的坐标系进行变换的道理是一样的）</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20220016.png" alt="屏幕截图 2024-10-22 220016"></p><p>这样一来，我们就抽象出下述公式（将基变换成我们想要的基）：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20220710.png" alt="屏幕截图 2024-10-22 220710"></p><h3 id="第十节-—-特征向量与特征值"><a href="#第十节-—-特征向量与特征值" class="headerlink" title="第十节 — 特征向量与特征值"></a>第十节 — 特征向量与特征值</h3><p>假设有一个向量线性变换后仍在它原本处在的直线上（如下述过程）。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-23%20181542.png" alt="屏幕截图 2024-10-23 181542"></p><p>将上述空间进行线性变换：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-23%20181552.png" alt="屏幕截图 2024-10-23 181552"></p><p>原先位于那条直线的向量仍处在那条直线上，只是与原本相比有缩放而已，在这条直线上的其余向量也是线性变换后落在这条直线上（因为其余向量与选定的向量只是缩放的关系，据我们所知，线性变换后这个关系依然成立）。</p><p>这些向量被称为特征向量，而量化它们线性变换前后的缩放比例被称为特征值。</p><p>特征值为1时，代表前后没有缩放，但不代表没有旋转。</p><p>因此，线性变换的作用与特征值和特征向量密切相关。</p><p>当特征向量有多个且可以张成整个空间时，我们可以把它当作基，称为特征基</p><p><img src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-23%20185414.png" alt="屏幕截图 2024-10-23 185414"></p><p>特征向量能够张成二维空间满秩，所以可以用特征向量作为基来表示任意的向量。特征基表示向量就不用移位，只需要伸缩，因为特征向量本来的定义就是不用伸缩的</p><p>对任意向量进行线性变换，将基转换为特征基，由二维举例，因为特征向量有多个且可以张成整个空间，任意向量都可以表示为ai+bj,如上图，a&#x3D;(a, 0)代表左边那一列，b&#x3D; (0,b)代表右边那一列。</p><h3 id="第十一节-—-抽象向量空间"><a href="#第十一节-—-抽象向量空间" class="headerlink" title="第十一节 — 抽象向量空间"></a>第十一节 — 抽象向量空间</h3><h3 id="第十二节-—-克莱姆法则与集合解释"><a href="#第十二节-—-克莱姆法则与集合解释" class="headerlink" title="第十二节 — 克莱姆法则与集合解释"></a>第十二节 — 克莱姆法则与集合解释</h3><h2 id="旅途的第二站（章）–-深入了解线性代数"><a href="#旅途的第二站（章）–-深入了解线性代数" class="headerlink" title="旅途的第二站（章）– 深入了解线性代数"></a>旅途的第二站（章）– 深入了解线性代数</h2><p><strong>参考视频：麻省理工学院 - MIT - 线性代数</strong></p><p><strong>参考书籍：Introduction to Linear Algebra(William Gilbert Strang)</strong></p><h2 id="旅途的第三站（章）–-线性代数的进阶（高等代数）"><a href="#旅途的第三站（章）–-线性代数的进阶（高等代数）" class="headerlink" title="旅途的第三站（章）– 线性代数的进阶（高等代数）"></a>旅途的第三站（章）– 线性代数的进阶（高等代数）</h2><p><strong>参考视频：高等代数———丘维生</strong></p><p><strong>参考书籍：丘维生的两本白皮书</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 纯数学Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50--梦开始的地方</title>
      <link href="/water.github.io/2024/10/07/CS50-%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/water.github.io/2024/10/07/CS50-%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="CS50-梦开始的地方"><a href="#CS50-梦开始的地方" class="headerlink" title="CS50-梦开始的地方"></a>CS50-梦开始的地方</h1><h2 id="Lecture2-–"><a href="#Lecture2-–" class="headerlink" title="Lecture2 –"></a>Lecture2 –</h2><h2 id="Lecture3-–-Array"><a href="#Lecture3-–-Array" class="headerlink" title="Lecture3 – Array"></a>Lecture3 – Array</h2><h2 id="Lecture4-–-memory"><a href="#Lecture4-–-memory" class="headerlink" title="Lecture4 – memory"></a>Lecture4 – memory</h2><p>众所周知，图像由像素组成，但在我们能在编写能够操作这类图像代码之前，我们需要新的语法来导航文件。</p><p>如何储存像图像一样的信息呢？</p><p>![10屏幕截图 2024-10-07 210107.png](<a href="https://github.com/WaterOfWinter/markdown_pic/blob/main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://github.com/WaterOfWinter/markdown_pic/blob/main/2024/10屏幕截图</a> 2024-10-07 210107.png?raw&#x3D;true)</p><h2 id="Lecture-5-–-Data-Structures"><a href="#Lecture-5-–-Data-Structures" class="headerlink" title="Lecture 5 – Data Structures"></a>Lecture 5 – Data Structures</h2><h3 id="抽象数据类型（Abstract-Data-Types）"><a href="#抽象数据类型（Abstract-Data-Types）" class="headerlink" title="抽象数据类型（Abstract Data Types）"></a>抽象数据类型（Abstract Data Types）</h3><p><strong>抽象数据类型：</strong>可以用多种方式来实现一种。</p><p><strong>queues(队列)</strong></p><p>队列的一个特性是先到先得（First in, First out）,就像视频中三个人排队拿饼干一样。</p><p>这样的结构提供了特定的操作：</p><p>enqueueing (入列)</p><p>dequeueing (出列)</p><p>如何在代码中实现一个队列呢？我们可以借助数组，正如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20123214.png" alt="屏幕截图 2024-10-13 123214"></p><p>但这里有一个问题，这串代码从一开始就规定了这个结构的总容量，如果定义了总容量为50，实际却只有三个人，那不是太浪费空间。</p><p>所以，我们需要另一种数据来在队列内部进行跟踪</p><p>计算机还有其他形式可以在内存中存储数据，还有一种被称为栈的抽象数据结构</p><p><strong>Stack(栈)</strong></p><p>栈和队列不同的是，栈的特性是后进先出（LIFO）</p><p>这个特性在日常生活经常用到，比如邮箱，总是最新的信息在最上面，使我们最先处理</p><p>栈也有两个特性：</p><p>push</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/107055ed59c55b3800977745067d7464ae.png" alt="img"></p><p>pop</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10f968ebadc94fe487e21965b74efb546d.png" alt="img"></p><p>但如果我们需要51，甚至更多呢？</p><p>在这之前，我们先来讨论一下老朋友数组：</p><p>我们知道数组的特性就是连续储存，事先决定数组容量，那我们如果想在一个容量为三的数组中添加第四个数，我们该怎么做呢？</p><p>首先，我们不能直接在数组末尾加上要添加的数，因为我们不知道下一步是垃圾值还是已经被占用内存的空间（如下图所示）</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20130955.png" alt="屏幕截图 2024-10-13 130955"></p><p>那我们在一个有充足内存的空间存放我们的数组，生成一个新数组，再把老数组释放</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20131025.png" alt="屏幕截图 2024-10-13 131025"></p><p>但这样必然会造成空间的浪费以及时间的增加（复制数组会运用循环）</p><p>为了解决这个问题，我们将引入链表：</p><p><strong>Linked-List(链表)</strong></p><p>我们将内存看成画布，你可以将所要存放的数据放在任何一个可存放的位置，为了链接它们，你可以使用箭头。</p><p>大致形式是这样的：那么我们如何实现呢？我们又要用到我们的老朋友了—–’指针‘</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20140025.png" alt="屏幕截图 2024-10-13 140025"></p><p>我们可以将这些指针更一般地称为元数据(metadata),它是实际的数据，因为它帮助我解决问题，从一个地方到另一个地方。但元数据与数据不同，因为我本质上不关注元数据，那是一个实现细节，但它确实帮助组织我的实际数据。换句话说，我们只关心它有什么作用，不关心它存放什么（不关心它存放的地址）。</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20140923.png" alt="屏幕截图 2024-10-13 140923"></p><p>链表的大致结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>创建一个链表，首先要设置一个好的初始值(设置为空，避免垃圾值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node* <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们要为一个节点分配空间,这有点像Java中的引用类型（C语言中叫指针类型，名字不重要），n只是存放那个真正存放数据的空间的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20141959.png" alt="屏幕截图 2024-10-13 141959"></p><p>如何向上图为这个节点存放number呢？我们试着给number传递数值（1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*n).number = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但日常我们不这么写，我们将*与.合并，得到下述代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;number = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>本质上，n还是一个指针。并且图示的箭头被形象地简化成代码中的“-&gt;”,so beautiful </p><p>我们还得记得给指向下一个的指针指向NULL,避免它指向垃圾值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>现在list可以指向我们创建的空间了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = node;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20143329.png" alt="屏幕截图 2024-10-13 143329"></p><p>接着，我们重复上述的操作，但有一点需要注意，我们不能再让list直接指向n了，因为这样会舍弃之前的空间</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20144332.png" alt="屏幕截图 2024-10-13 144332"></p><p>我们应该实现下列图示的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20144002.png" alt="屏幕截图 2024-10-13 144002"></p><p>具体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = n;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = atoi(argv[i]);     <span class="comment">// atoi将字符串（数组）转换为数字</span></span><br><span class="line">        <span class="comment">// printf(&quot;%i\n&quot;, argv[i]);</span></span><br><span class="line">        </span><br><span class="line">        node *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// free memory thus for</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-&gt;number = number;</span><br><span class="line">        n-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print while list</span></span><br><span class="line">    node *ptr = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, ptr-&gt;number);</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptr作用过程图示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20150347.png" alt="屏幕截图 2024-10-13 150347"></p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20150408.png" alt="屏幕截图 2024-10-13 150408"></p><p>然而，我们想要搜索一个指定数值时，由于这些内存块并不是一个挨着一个，所以我们不能使用二分搜索。</p><p>以上代码是在前面添加，那我们再写一个在后面添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = atoi(argv[i]);     <span class="comment">// atoi将字符串（数组）转换为数字</span></span><br><span class="line">        <span class="comment">// printf(&quot;%i\n&quot;, argv[i]);</span></span><br><span class="line">        </span><br><span class="line">        node *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// free memory thus for</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-&gt;number = number;</span><br><span class="line">        n-&gt;next = null;</span><br><span class="line">        <span class="comment">// If list is empty</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Iterate over numbers already</span></span><br><span class="line">           <span class="keyword">for</span> (node *ptr = <span class="built_in">list</span>; ptr != <span class="literal">NULL</span>; ptr = ptr-&gt;next) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// if at the end of list</span></span><br><span class="line">               <span class="keyword">if</span> (ptr-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// Append node</span></span><br><span class="line">                   ptr-&gt;next = n;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print while list</span></span><br><span class="line">    node *ptr = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, ptr-&gt;number);</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的运行时间区别：前者是O(1), 后者是O(n);</p><p>最终版本如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = atoi(argv[i]);     <span class="comment">// atoi将字符串（数组）转换为数字</span></span><br><span class="line">        <span class="comment">// printf(&quot;%i\n&quot;, argv[i]);</span></span><br><span class="line">        </span><br><span class="line">        node *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// free memory thus for</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-&gt;number = number;</span><br><span class="line">        n-&gt;next = null;</span><br><span class="line">        <span class="comment">// If list is empty</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If number belongs at beginning of list</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n-&gt;number &lt; <span class="built_in">list</span>-&gt;number) </span><br><span class="line">        &#123;</span><br><span class="line">        n-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">            <span class="built_in">list</span> = n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if number belong later in last</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Iterate over numbers already</span></span><br><span class="line">           <span class="keyword">for</span> (node *ptr = <span class="built_in">list</span>; ptr != <span class="literal">NULL</span>; ptr = ptr-&gt;next) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// if at the end of list</span></span><br><span class="line">               <span class="keyword">if</span> (ptr-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// Append node</span></span><br><span class="line">                   ptr-&gt;next = n;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> (n-&gt;number &lt; ptr-&gt;next-&gt;number) </span><br><span class="line">               &#123;</span><br><span class="line">                   n-&gt;next = ptr-&gt;next;</span><br><span class="line">                   ptr-&gt;next = n;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print while list</span></span><br><span class="line">    node *ptr = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, ptr-&gt;number);</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但即使是这样，仍然有时间上的缺点O(N),有没有一种方法可以两全其美呢？</p><p><strong>Tree(树)</strong></p><p>binary search trees(二叉搜索树）</p><p>每一个节点都由一个数据和两个指针组成</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20161333.png" alt="屏幕截图 2024-10-13 161333"></p><p>节点代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>搜索某个指定的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool search(node *tree, int number) </span><br><span class="line">&#123;</span><br><span class="line">if (tree == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if (number &lt; tree-&gt;number)</span><br><span class="line">&#123;</span><br><span class="line">return search(tree-&gt;left, number);</span><br><span class="line">&#125;</span><br><span class="line">else if (number &gt; tree-&gt;number)</span><br><span class="line">&#123;</span><br><span class="line">return search(tree-&gt;right, number);</span><br><span class="line">&#125;</span><br><span class="line">else if (number == tree-&gt;number)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果tree没有上面那么beautiful呢</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20162924.png" alt="屏幕截图 2024-10-13 162924"></p><p>这将在《数据结构的旅程》中讨论…</p><p>接下来，我们将讨论数组与链表的组合</p><p><strong>字典</strong>（dictionaries）</p><p>类比英译汉字典，其中的单词与中文意思在这里更通常被称为键和值</p><p>日常手机自带的电话联系人就运用了这种抽象数据结构</p><p><strong>散列</strong>（hashing&#x2F;哈希）</p><p>在数学或代码中，它实际上可以接受任意数量的输入并将它们映射到有限数量的输出</p><p>类比定义域与值域，假如有一个无限的定义域，但散列函数将它们缩减到一个有限的值域，具有特定的值。</p><p>hash table</p><p>是一种混合体，是数组和链表的结合，我们借用联系人来体会一下：</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20165345.png" alt="屏幕截图 2024-10-13 165345"></p><p>hash table的时间复杂度为O(n)</p><p>节点代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">node *table[<span class="number">26</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">toupper</span>(word[<span class="number">0</span>]) - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组中每一项都十分均匀时，时间复杂度为O(n&#x2F;k)(k是数组长度)</p><p><strong>Tries(前缀树)</strong></p><p>trie –&gt; retrieval(检索)的简称</p><p>它是数组与树的混合，搜索的时间复杂度继承了数组的优点，O(1)</p><p><img src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-13%20171746.png" alt="屏幕截图 2024-10-13 171746"></p><p>节点代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">children</span>[26];</span></span><br><span class="line">    <span class="type">char</span> *number;</span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>如果想要利用这个来查找人名，所消耗的速度仅与姓名长度有关</p><p>但也有个很大的缺点，如图所示，可能会有许多空指针，这十分浪费内存，牺牲空间换取时间，让我们体会空间与时间的平衡艺术。</p><h2 id="Lecture6-–-Python"><a href="#Lecture6-–-Python" class="headerlink" title="Lecture6 – Python"></a>Lecture6 – Python</h2><h2 id="Lecture7-–-SQL"><a href="#Lecture7-–-SQL" class="headerlink" title="Lecture7 – SQL"></a>Lecture7 – SQL</h2><p>存储大量数据的最简单方式是一个字面意义上的文本文件，文件名以<code>.txt</code>结尾或者是<code>.csv</code>.</p><h3 id="flat-file-database"><a href="#flat-file-database" class="headerlink" title="flat-file database"></a>flat-file database</h3><p>平面文件数据库实际上是指一个包含所有数据的文本文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机Computer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
