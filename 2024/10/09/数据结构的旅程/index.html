<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构的旅程 | Water's study corner</title><meta name="author" content="water"><meta name="copyright" content="water"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="*数据结构的旅程参考课程：CS61B 参考文档：Qiushao的CS61B笔记以及 CS61B自身文档 本文档相当于CS61B文档的简略翻译版 JavaIntroductionJava与C语言这种面对过程的语言不同，它是面对对象的，我浅显的理解是：面对对象就是将一个完整的工作流程划分为不同对象，而面对过程是将一个完整的工作流程切割为不同小的过程。具体划分形式是创建文件。 对象交互原则：低耦合，高内">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构的旅程">
<meta property="og:url" content="https://waterofwinter.github.io/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/index.html">
<meta property="og:site_name" content="Water&#39;s study corner">
<meta property="og:description" content="*数据结构的旅程参考课程：CS61B 参考文档：Qiushao的CS61B笔记以及 CS61B自身文档 本文档相当于CS61B文档的简略翻译版 JavaIntroductionJava与C语言这种面对过程的语言不同，它是面对对象的，我浅显的理解是：面对对象就是将一个完整的工作流程划分为不同对象，而面对过程是将一个完整的工作流程切割为不同小的过程。具体划分形式是创建文件。 对象交互原则：低耦合，高内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://waterofwinter.github.io/water.github.io/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241017164223.jpg">
<meta property="article:published_time" content="2024-10-09T10:14:31.000Z">
<meta property="article:modified_time" content="2024-11-04T12:06:26.373Z">
<meta property="article:author" content="water">
<meta property="article:tag" content="计算机Computer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://waterofwinter.github.io/water.github.io/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241017164223.jpg"><link rel="shortcut icon" href="/water.github.io/"><link rel="canonical" href="https://waterofwinter.github.io/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/water.github.io/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/water.github.io/',
  algolia: undefined,
  localSearch: {"path":"/water.github.io/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构的旅程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 20:06:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_HTML"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar."><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/water.github.io/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241017164223.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/water.github.io/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/water.github.io/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/water.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/water.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/water.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/water.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/water.github.io/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/water.github.io/images/103008653_p0_master1200.jpg')"><nav id="nav"><span id="blog-info"><a href="/water.github.io/" title="Water's study corner"><span class="site-name">Water's study corner</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/water.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/water.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/water.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/water.github.io/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/water.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构的旅程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-09T10:14:31.000Z" title="发表于 2024-10-09 18:14:31">2024-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-04T12:06:26.373Z" title="更新于 2024-11-04 20:06:26">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构的旅程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构的旅程"><a href="#数据结构的旅程" class="headerlink" title="*数据结构的旅程"></a>*数据结构的旅程</h1><p>参考课程：CS61B</p>
<p>参考文档：Qiushao的CS61B笔记以及 CS61B自身文档</p>
<p>本文档相当于CS61B文档的简略翻译版</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Java与C语言这种面对过程的语言不同，它是面对对象的，我浅显的理解是：面对对象就是将一个完整的工作流程划分为不同对象，而面对过程是将一个完整的工作流程切割为不同小的过程。具体划分形式是创建文件。</p>
<p>对象交互原则：低耦合，高内聚。人话：低耦合指的是对象之间的依赖关系尽可能少。对象应该尽量独立，使得一个对象的变化不会影响到其他对象。高内聚指的是一个对象内部的各个部分紧密相关，负责的功能相对集中。每个对象应专注于其特定的职责。</p>
<h3 id="Java-Workflow"><a href="#Java-Workflow" class="headerlink" title="Java Workflow"></a>Java Workflow</h3><p>由于CS61B使用Java来讲解数据结构，所以在学习数据结构前，我们先来熟悉一下Java.</p>
<p>Taking a program from a <code>.java</code> file into an executable has two main steps in Java: <strong>compilation</strong> and <strong>interpretation</strong>. </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20115000.png" alt="屏幕截图 2024-10-22 115000"></p>
<p>在Java中，<strong>编译</strong>和<strong>解释</strong>是两个不同的过程，它们在程序执行中扮演不同的角色：</p>
<ol>
<li><strong>编译</strong>：<ul>
<li>将Java源代码（<code>.java</code>文件）转换成字节码（<code>.class</code>文件）。这个过程由Java编译器（如<code>javac</code>）完成。</li>
<li>字节码是平台无关的，可以在任何支持Java的环境中运行。</li>
</ul>
</li>
<li><strong>解释</strong>：<ul>
<li>运行时，Java虚拟机（JVM）将字节码转换为机器码并执行。这个过程是动态的，因此可以根据不同的操作系统和硬件进行调整。</li>
<li>解释允许Java程序具备跨平台能力，因只需JVM在目标环境中存在。</li>
</ul>
</li>
</ol>
<p>总结而言，编译是将源代码转换为字节码的过程，而解释是在运行时执行这些字节码的过程。这样结合使得Java具有了可移植性和安全性。</p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a><strong>Command Line Arguments</strong></h3><p>与C语言相似，java也有之间的main函数，我们也可以看到C语言中熟悉的命令行参数（如下图）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ArgsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们如下图使用命令行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java ArgsDemo these are command line arguments</span><br><span class="line">these</span><br></pre></td></tr></table></figure>

<p>上述过程中解释器将这些参数收集起来，并将它们作为字符串数组传递给<code>main</code>方法的参数（<code>String[] args</code>）</p>
<p>因此，<code>String[] args</code> 是连接用户输入（命令行参数）和程序执行（解释过程）的桥梁。</p>
<h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>Java中也有类似C语言中的数据类型。数据类型分为<strong>primitive types</strong>和 <strong>reference types</strong></p>
<ul>
<li>primitive types：<code>byte, short, int, long, float, double, boolean, char.</code> </li>
<li>reference types: 除此之外，都是引用类型。</li>
</ul>
<h4 id="The-Golden-Rule-of-Equals-GRoE"><a href="#The-Golden-Rule-of-Equals-GRoE" class="headerlink" title="The Golden Rule of Equals (GRoE)"></a>The Golden Rule of Equals (GRoE)</h4><p>When you write <code>y = x</code>, you are telling the Java interpreter to copy the bits from x into y. </p>
<h3 id="Object-Instantiation"><a href="#Object-Instantiation" class="headerlink" title="Object Instantiation"></a><strong>Object Instantiation</strong></h3><p>classes can be instantiated, and instances can hold data。（实例化是面向对象编程的核心，允许你创建和使用类的具体对象，进而实现数据封装和行为定义。）</p>
<ol>
<li><strong>定义类</strong>：首先定义一个类，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>实例化对象</strong>：使用<code>new</code>关键字创建对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>访问对象成员</strong>：可以通过对象访问类的属性和方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(myDog.name); <span class="comment">// 输出：Buddy</span></span><br></pre></td></tr></table></figure>

<p>实例化与没有实例化的区别：</p>
<p><strong>实例化（创建对象）</strong>：</p>
<ul>
<li><p>通过<code>new</code>关键字创建一个类的对象。</p>
</li>
<li><p>你可以访问对象的属性和方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">System.out.println(myDog.name); <span class="comment">// 访问实例变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p><strong>没有实例化</strong>：</p>
<ul>
<li><p>你仅有类的定义，但没有创建任何对象。</p>
</li>
<li><p>不能直接访问类的属性或方法。例如，如果没有实例化，不能使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Dog myDog; <span class="comment">// 只是声明，没有创建对象</span></span><br><span class="line">System.out.println(myDog.name); <span class="comment">// 会报错，因为myDog没有指向任何对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>总结而言，实例化是让类成为具体对象的过程，而没有实例化则意味着仅有类的定义，没有实际的对象可以使用。实例化是执行程序中面向对象操作的关键。</p>
<h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>在实例化对象，我们发现有用到<code>new</code>这个关键词，它有什么作用呢？</p>
<p>课本原文：</p>
<p>Java first allocates a box for each instance variable of the class, and fills them with a default value. The constructor then usually (but not always) fills every box with some other value.</p>
<p>大致意思：<code>new</code>分配<code>constructor</code>构造函数所需的内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Walrus someWalrus;</span><br><span class="line">someWalrus = <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br></pre></td></tr></table></figure>

<p>正如上面所示：我们分配一个足够的空间给海象。注意：<code>someWalrus</code>只是储存分配空间的地址，<code>new Walrus(1000, 8.3)</code>是真正分配空间的地方。就像somWarlus是一张藏宝图，标记宝藏的位置，而后者被埋在一块待发现挖掘的地方。类似于C语言里的指针。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-22%20135201.png" alt="屏幕截图 2024-10-22 135201"></p>
<p>它们所存放的内存位置也不同，someWalrus被放在栈内存，<code>new Walrus(100, 8.3)</code>中的实例变量存放在堆内存。</p>
<p>在这里插一篇看过的博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43430343/article/details/119709715?ops_request_misc=%7B%22request_id%22:%22196B88EE-44D9-4DE9-A76A-D329F23AE38A%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=196B88EE-44D9-4DE9-A76A-D329F23AE38A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-22-119709715-null-null.142%5Ev100%5Epc_search_result_base6&utm_term=java%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%8Enew%E5%AD%98%E6%94%BE%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">Java对象在内存中实例化_java对象在内存中实例化的过程-CSDN博客</a></p>
<h3 id="Java-Members"><a href="#Java-Members" class="headerlink" title="Java Members"></a>Java Members</h3><p>Java一个类中有以下两个元素组成：</p>
<ul>
<li>变量（属性）</li>
<li>方法</li>
</ul>
<h4 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h4><p>变量分为实例变量与类变量：</p>
<ol>
<li><p>实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些变量要被使用，需要经过以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog d;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.weightInPounds = <span class="number">20</span>;</span><br><span class="line">        d.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">binomen</span> <span class="operator">=</span> <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些变量是归属于类的，而不是实例。使用类变量如上述的binomen：<code>Dog.binomen</code>,而不用像实例变量实例化一个对象。</p>
</li>
</ol>
<p>总而言之，类变量是归属于类的，实例变量是归属于对象的。</p>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>方法也分为实例变量与类变量：</p>
<ol>
<li><p>实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d2);</span><br></pre></td></tr></table></figure>


</li>
<li><p>类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总而言之，类方法是归属于类的，实例方法是归属于对象的。</p>
<p>从上面的变量与方法的分类，我们可以发现类变量或方法在声明定义之前都会带有static这个关键词， <code>static</code> 是一个<strong>修饰符</strong>，用于指示类变量或类方法属于类本身，而不是特定的对象。使用 <code>static</code> 声明的变量或方法可以通过类名直接访问，而不需要创建类的实例。</p>
<p>所以，类变量&#x2F;方法还有一个别名–静态变量&#x2F;方法，而实例变量&#x2F;方法则称作非静态变量&#x2F;方法。</p>
<p>注意：</p>
<ul>
<li><p>静态方法不能调用非静态方法</p>
</li>
<li><p>非静态方法能调用静态方法</p>
<p><strong>原因：</strong>静态方法属于类，随着类的加载而加载，在内存中优先于对象创建。非静态方法属于对象，在对象创建时才会加载。由于静态 方法在对象存在之前就已经存在，因此它无法调用非静态方法，因为非静态方法需要依赖于具体的对象实例才能执行‌。</p>
<p><strong>static的运用</strong>：工具类（我不想调用一些方法时，还要实例化一个对象）</p>
</li>
</ul>
<h3 id="Constructors-in-Java"><a href="#Constructors-in-Java" class="headerlink" title="Constructors in Java"></a><strong>Constructors in Java</strong></h3><p>之前说过，实例变量&#x2F;实例方法会封装数据，那么类实例化又是怎么操作的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> w)</span> &#123;     </span><br><span class="line">        weightInPounds = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类别："><a href="#类别：" class="headerlink" title="类别："></a>类别：</h4><ul>
<li><strong>无参构造函数（Default Constructor）</strong>：如果你没有显式定义构造函数，Java会为类生成一个默认的无参构造函数。它什么都不做，只是创建对象。</li>
<li><strong>有参构造函数（Parameterized Constructor）</strong>：通过这种构造函数，我们可以在对象创建时直接传入参数，给实例变量赋值。可以定义多个有参构造函数（重载），以便根据不同的需求灵活地创建对象.(上述的就是一个有参构造函数)。</li>
</ul>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul>
<li><strong>初始化对象</strong>：构造函数确保在对象创建时，所有必要的数据或资源（如实例变量的初始值）已经准备就绪。</li>
<li><strong>灵活性</strong>：通过构造函数的重载，可以根据不同的场景初始化对象，从而提供更大的灵活性。</li>
</ul>
<h4 id="构造函数与实例化的关系："><a href="#构造函数与实例化的关系：" class="headerlink" title="构造函数与实例化的关系："></a>构造函数与实例化的关系：</h4><p><strong>实例化（Instantiation）</strong>：实例化是创建类的对象的过程，使用 <code>new</code> 关键字实现。这个过程中，构造函数被调用，并为对象的实例变量分配内存并初始化。没有构造函数的参与，无法完成对象的完整初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);  <span class="comment">// 实例化并初始化对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="构造函数与封装的关系"><a href="#构造函数与封装的关系" class="headerlink" title="构造函数与封装的关系:"></a>构造函数与封装的关系:</h4><p><strong>封装（Encapsulation）</strong>：封装是面向对象编程中将数据和行为绑定在一起，同时隐藏对象的内部实现细节的原则。通常，类中的属性会被定义为私有（<code>private</code>），从而避免外部直接访问。这时候构造函数作为一种合法方式，允许外部通过参数化的方式安全地设置这些私有数据的初始状态，而不会破坏封装性。</p>
<p>比如在上面的 <code>Person</code> 类中，<code>name</code> 和 <code>age</code> 都是私有的，外部无法直接访问或修改这些变量，但通过构造函数，我们可以在实例化时安全地初始化它们。</p>
<h4 id="实例化与封装数据的关系"><a href="#实例化与封装数据的关系" class="headerlink" title="实例化与封装数据的关系:"></a>实例化与封装数据的关系:</h4><p><strong>封装数据</strong> 是指将对象的内部数据隐藏起来，只能通过类内部的方法（如getter和setter）来访问或修改。实例化时，构造函数会为私有属性赋初值，从而完成对象的初始化。这种通过构造函数赋初值的方式，不仅符合封装的原则，也保证了数据的完整性和安全性。</p>
<h3 id="Public-Private-Protected-default"><a href="#Public-Private-Protected-default" class="headerlink" title="Public&amp;&amp;Private&amp;&amp;Protected&amp;&amp;default"></a>Public&amp;&amp;Private&amp;&amp;Protected&amp;&amp;default</h3><p>我们可以发现多数变量&#x2F;方法定义前都会带有public这样之类的修饰符，这有什么用，不同的修饰符又有什么区别呢？</p>
<ol>
<li><strong>public</strong>：可以被任何类访问。</li>
<li><strong>private</strong>：只能在定义它的类内部访问。</li>
<li><strong>protected</strong>：可以在同一包中的其他类和所有子类中访问。</li>
<li><strong>default</strong>（无修饰符）：仅在同一包中的类可以访问，称为包私有。</li>
</ol>
<p>到这里，Java的大致内容差不多已经学习完了，其余的内容将会在学习数据结构的过程中补充。</p>
<h2 id="IntList"><a href="#IntList" class="headerlink" title="IntList"></a>IntList</h2><p>数组是一个好用的工具，但是它的大小是固定的，为了解决这个问题，我们将搭建一个列表List.</p>
<p>List的基本框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要有<code>get()</code>来获取元素，<code>size()</code>标记大小。</p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">        <span class="keyword">public</span> IntList rest;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">            first = f;</span><br><span class="line">            rest = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the size of the listing using.....recursion</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rest.size() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(first, rest);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            totalSize += <span class="number">1</span>;</span><br><span class="line">            p = p.rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest.get(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 反向构建列表</span></span><br><span class="line">        <span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">25</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">35</span>, L);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">45</span>, L);</span><br><span class="line">        System.out.println(L.size());</span><br><span class="line">        System.out.println(L.iterativeSize());</span><br><span class="line">        System.out.println(L.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SLList"><a href="#SLList" class="headerlink" title="SLList"></a>SLList</h2><h3 id="naked-recursive"><a href="#naked-recursive" class="headerlink" title="naked recursive"></a><strong>naked recursive</strong></h3><p>he issue is that the <code>IntList</code> is what I call a <strong>naked recursive</strong> data structure.(裸递归)</p>
<p>裸递归是指在处理递归数据结构时，直接使用递归调用而没有任何额外的处理或封装。<code>IntList</code> 的<code> size（）</code> 方法就是一个典型的例子。这个方法通过递归计算列表的大小。</p>
<p>“裸递归”的主要问题在于：</p>
<ol>
<li><strong>缺乏安全性</strong>：在递归调用中，如果没有明确的边界条件，可能会导致栈溢出（Stack Overflow）。</li>
<li><strong>可读性差</strong>：递归的逻辑可能不够直观，特别是对不熟悉递归的开发者来说。</li>
<li><strong>性能问题</strong>：某些情况下，递归调用会导致重复计算，影响效率。</li>
</ol>
<p>所以我们来优化它！！</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>相关代码如下：</p>
<p>将IntList重命名为IntNode,并作为SLList的嵌套类（nest class）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">    item = i;</span><br><span class="line">    next = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较创建对象时的好处：简化了操作。（Essentially, the <code>SLList</code> class acts as a middleman between the list user and the naked recursive data structure）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20102856.png" alt="屏幕截图 2024-10-24 102856"></p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;Pineapple&gt; &#123;</span><br><span class="line">    <span class="comment">// Dear user, you do not touch this...</span></span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Pineapple item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(Pineapple f, IntNode l)</span> &#123;</span><br><span class="line">            item = f;</span><br><span class="line">            next = l;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(Pineapple x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add items to the front of the list...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Pineapple i)</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(i, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pineapple <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Pineapple x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>&lt;&gt;</code>(例如<code>&lt;Pineapple&gt;</code>)是一种占位词，括号里面的可以是任何东西，使用它的时候要说明它的类型。</p>
<h2 id="DLList"><a href="#DLList" class="headerlink" title="DLList"></a>DLList</h2><p>SLList实现了从前向后依次查找，为了还可以从后往前，我们要搭建DLList。</p>
<p>仿照SLList的思路，我们在后面也布置一个哨兵。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104038.png" alt="屏幕截图 2024-10-24 104038"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104051.png" alt="屏幕截图 2024-10-24 104051"></p>
<p>此时，每个节点都可以访问前面与后面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往前一步，我们可以让两个哨兵合二为一。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104722.png" alt="屏幕截图 2024-10-24 104722"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20104745.png" alt="屏幕截图 2024-10-24 104745"></p>
<p>大致代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;BleepBlorp&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> BleepBlorp item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>DLLIst</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;Integer&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Alist"><a href="#Alist" class="headerlink" title="Alist"></a>Alist</h2><p>首先解释一下为什么要介绍Alist(也就是数组列表)，明明上节课的Dlist已经足够完美了，但我们在查找特定元素时，我们会发现Dlist无法直接一步到位，需要用到循环，但是如果是Alist的话，利用数组的特性就可以实现一步到位。啊哈，让我们从零开始建造Alist吧！！</p>
<p>实例化数组的三种方法：</p>
<ul>
<li><p><code>int[] x = new int[n];</code> (<code>x[0] = 1;</code>…)       </p>
</li>
<li><p><code>int[] y = new int&#123;1, 2, 3, 4, 5&#125;;</code></p>
</li>
<li><p><code>int[] z = &#123;9, 10, 11, 12, 13&#125;;</code></p>
<p>此外，数组复制Java也有自带的函数arraycopy().</p>
<p><code>int[] b = &#123;9, 10, 11&#125;; System.arraycopy(b, 0, x, 3, 2);</code></p>
<p>其中，各参数为：</p>
<ul>
<li>The array to use as a source</li>
<li>Where to start in the source array</li>
<li>The array to use as a destination</li>
<li>Where to start in the destination array</li>
<li>How many items to copy</li>
</ul>
</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="comment">// size = 2</span></span><br><span class="line">    <span class="comment">// 5 6 0 8 0 0 0 0 0...</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create empty List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reSize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">        items = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            reSize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resize方法中你会发现容量是成倍增长的。因为如果每当添加一个数，容量加一。可想而知，所消耗的时间是多么长，效率十分低。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20203035.png" alt="屏幕截图 2024-10-15 203035"></p>
<p>虽然提高了效率，但当数组十分大的时候，再运用这个方法，就会有大量的空缺，造成大量的内存浪费。</p>
<p>上述代码仅适用于int类型，为了它更好地发挥它的作用，我们要用到我们的老朋友占位词。但是这里我们发现对数组直接使用占位词，你会发现有问题。这里我直接引用Qingsu关于这个问题的解决方案（如下图）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20204117.png" alt="屏幕截图 2024-10-15 204117"></p>
<h2 id="Inheritance-I"><a href="#Inheritance-I" class="headerlink" title="Inheritance I"></a>Inheritance I</h2><h3 id="Override-default-interface"><a href="#Override-default-interface" class="headerlink" title="Override &amp;&amp; default &amp;&amp; interface"></a>Override &amp;&amp; default &amp;&amp; interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">longestString</span> <span class="operator">=</span> list.get(maxDex);</span><br><span class="line">        <span class="type">String</span> <span class="variable">thisString</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        <span class="keyword">if</span> (thisString.length() &gt; longestString.length()) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(maxDex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上述代码想要接受的变量类型想要是<code>ALList&lt;String&gt;</code>,我们可能又要重写一遍，但我们发现之前ALList与SLList所拥有的方法差不多，我们可以使用一个类似购物清单的接口，上面写着所要实现的方法,关键词<code>interface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;cheese&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的大多数方法都只告诉有什么方法，具体操作要在子类中实现(<code>implements</code>)，所使用的关键词是<code>Override</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &lt;cheese&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;cheese&gt;&#123;</span><br><span class="line">    <span class="comment">// size = 2</span></span><br><span class="line">    <span class="comment">// 5 6 0 8 0 0 0 0 0...</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">    <span class="keyword">private</span> cheese[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create empty List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (cheese[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reSize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cheese[] temp = (cheese[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">        items = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            reSize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">cheese</span> <span class="variable">last</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;cheese&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;cheese&gt; &#123;</span><br><span class="line">    <span class="comment">// Dear user, you do not touch this...</span></span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> cheese item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(cheese f, IntNode l)</span> &#123;</span><br><span class="line">            item = f;</span><br><span class="line">            next = l;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add items to the front of the list...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(cheese i)</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(i, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(cheese x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> cheese <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SLList&lt;String&gt; L1 = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        L1.addFirst(<span class="string">&quot;What&quot;</span>);</span><br><span class="line"></span><br><span class="line">        L1.addLast(<span class="string">&quot;THis&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(L1.getFirst ());</span><br><span class="line"></span><br><span class="line">        SLList&lt;Integer&gt; L2 = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Integer&gt;();</span><br><span class="line">        L2.addFirst(<span class="number">10</span>);</span><br><span class="line">        L2.addLast(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一些接口中的方法也会编写一个默认的方法（使用关键词<code>default</code>）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倘若不想要接口中的默认方法，也可以覆盖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-method-selection"><a href="#dynamic-method-selection" class="headerlink" title="dynamic method selection"></a><strong>dynamic method selection</strong></h3><p>java会怎么选择哪一个方法来调用呢？—– 动态方法选择</p>
<p><code>List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</code></p>
<p>在上面的声明和实例化中，lst的类型是“List61B”。这被称为“静态类型”</p>
<p>然而，对象本身也有类型。lst指向的对象是SLList类型的。尽管这个对象本质上是一个SLList（因为它是这样声明的），但它也是一个List61B。但是，由于对象本身是使用SLList构造函数实例化的，因此我们称其为“动态类型”。</p>
<p>如果lst被重新赋值指向另一种类型的对象，比如一个Alist对象，那么lst的动态类型现在将是Alist而不是SLList！它是动态的，因为它根据当前引用的对象类型而改变。</p>
<p>当Java运行被覆盖的方法时，它会在其动态类型中搜索适当的方法签名并运行它。</p>
<p>当java有两个名称相同参数不同的方法，Java检查要调用哪个方法时，它检查静态类型并调用具有相同类型参数的方法。</p>
<h3 id="Superclass-Subclass"><a href="#Superclass-Subclass" class="headerlink" title="Superclass &amp;&amp; Subclass"></a>Superclass &amp;&amp; Subclass</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-27%20112203.png"></p>
<p>作为超类的接口以及继承它的子类关系如上。</p>
<h2 id="Inheritance-II"><a href="#Inheritance-II" class="headerlink" title="Inheritance II"></a>Inheritance II</h2><h3 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h3><p>到目前为止，我们一直在编写类和接口，您可能已经注意到我们必须为不同或相似的类编写冗余代码的地方。因此，我们有了继承的概念：一个类&#x2F;对象不需要重新定义它的所有方法，而是可以使用父类的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;Blorp&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Blorp&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="type">Blorp</span> <span class="variable">oldBack</span> <span class="operator">=</span> removeLast();</span><br><span class="line">              addFirst(oldBack);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Because of extends, RotatingSLList inherits all members of SLList:</p>
<ul>
<li>All instance and static variables.</li>
<li>All methods.</li>
<li>All nested classes.</li>
<li>Constructors are <strong>not</strong> inherited!</li>
</ul>
<p>在Java中，<code>extends</code> 和 <code>implements</code> 是用来实现类和接口之间关系的两个关键字。它们的关系与区别如下：</p>
<h4 id="1-extends"><a href="#1-extends" class="headerlink" title="1. extends"></a>1. <code>extends</code></h4><ul>
<li><p><strong>作用</strong>：用于表示一个类继承另一个类。子类可以继承父类的属性和方法。</p>
</li>
<li><p><strong>单继承</strong>：Java 中的类只能直接继承一个父类，即支持单继承。</p>
</li>
<li><p><strong>语法</strong>：<code>class 子类名 extends 父类名 &#123; &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系图如下：</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10list_subclasses.png" alt="list_subclasses"></p>
<h4 id="2-implements"><a href="#2-implements" class="headerlink" title="2. implements"></a>2. <code>implements</code></h4><ul>
<li><p><strong>作用</strong>：用于表示一个类实现一个或多个接口。类必须实现接口中定义的所有方法。</p>
</li>
<li><p><strong>多实现</strong>：一个类可以实现多个接口，这支持了Java的多重继承特性（虽然类本身不支持多继承）。</p>
</li>
<li><p><strong>语法</strong>：<code>class 类名 implements 接口名1, 接口名2 &#123; &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sound</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Sound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-关系与区别"><a href="#3-关系与区别" class="headerlink" title="3. 关系与区别"></a>3. 关系与区别</h4><ul>
<li>关系<ul>
<li><code>extends</code> 主要用于类之间的继承关系，形成类的层次结构。</li>
<li><code>implements</code> 主要用于类与接口之间的实现关系，允许类遵循某种协议或行为。</li>
</ul>
</li>
<li>区别<ul>
<li>继承（<code>extends</code>）会带来代码重用，可以直接使用父类的方法和属性，而实现（<code>implements</code>）则需要在类中提供具体的方法实现。</li>
<li>在继承中，子类只可以有一个直接父类；而实现中，一个类可以实现多个接口，增加了灵活性。</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>使用 <code>extends</code> 时，类之间形成父子关系，支持单继承；使用 <code>implements</code> 时，类与接口之间形成实现关系，支持多实现。这两者各有用途，适用于不同的设计场景。</li>
</ul>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><p>this和super功能上相似：</p>
<p><strong>this</strong>: 引用当前对象.<code>this</code> 关键字用于引用当前对象的成员变量和方法。它可以帮助区分局部变量和实例变量，特别是在构造函数中。</p>
<p><strong>super</strong>:访问父类成员：<code>super</code> 关键字用于访问父类的成员变量和方法。当子类与父类有同名的成员变量或方法时，可以使用 <code>super</code> 来明确访问父类的成员。</p>
<h4 id="super-和-this-的关系"><a href="#super-和-this-的关系" class="headerlink" title="super 和 this 的关系"></a><code>super</code> 和 <code>this</code> 的关系</h4><ul>
<li><p><code>this</code> 和 <code>super</code> 可以在构造函数中同时使用。可以在构造函数的第一行使用 <code>super()</code> 调用父类的构造函数，或者使用 <code>this()</code> 调用同类的另一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Child() &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><h4 id="1-Java封装（Encapsulation）"><a href="#1-Java封装（Encapsulation）" class="headerlink" title="1. Java封装（Encapsulation）"></a>1. Java封装（Encapsulation）</h4><ul>
<li><p><strong>定义</strong>：封装是将对象的状态（属性）和行为（方法）绑定在一起，并通过访问控制修饰符来限制对内部状态的直接访问。</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><strong>访问修饰符</strong>：Java提供了几种访问修饰符（如 <code>private</code>、<code>protected</code>、<code>public</code> 和包级别）来控制类的成员（变量和方法）的可见性。</li>
<li><strong>Getter 和 Setter 方法</strong>：通常，通过提供公共的 Getter 和 Setter 方法来访问和修改私有属性，以实现对对象状态的控制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name; // 私有属性</span><br><span class="line"></span><br><span class="line">    // Getter 方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Setter 方法</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-模块封装"><a href="#2-模块封装" class="headerlink" title="2. 模块封装"></a>2. 模块封装</h4><ul>
<li><p><strong>定义</strong>：模块封装是Java 9引入的概念，用于对类和包进行更高层次的组织。模块是一个包含相关包的集合，模块可以定义自己的公共API，并隐藏内部实现。</p>
</li>
<li><p><strong>功能</strong>：模块可以控制哪些类和包是公开的，哪些是私有的，通过 <code>module-info.java</code> 文件来声明模块的依赖关系和导出内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module com.example &#123;</span><br><span class="line">    exports com.example.api; // 导出公共API</span><br><span class="line">    requires com.othermodule; // 依赖其他模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-封装与模块封装的关系"><a href="#3-封装与模块封装的关系" class="headerlink" title="3. 封装与模块封装的关系"></a>3. 封装与模块封装的关系</h4><ul>
<li><strong>层次</strong>：<ul>
<li>封装是对类和对象的管理，它主要关注于如何保护对象的状态和行为，限制外部对对象内部状态的直接访问。</li>
<li>模块封装则是在更高层次上组织代码，关注的是如何将一组相关的类和包组合在一起，提供公共接口，并管理模块之间的依赖关系。</li>
</ul>
</li>
<li><strong>互补性</strong>：<ul>
<li>封装确保了类的内部实现细节被隐藏，而模块封装则确保了整个模块的内部实现细节被隐藏。二者结合使用可以提高代码的可维护性和可重用性。</li>
</ul>
</li>
</ul>
<h3 id="Higher-Order-Functions-in-Java"><a href="#Higher-Order-Functions-in-Java" class="headerlink" title="Higher Order Functions in Java"></a>Higher Order Functions in Java</h3><p>Java中参数可以间接传递函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HoFDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">   		<span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   		System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inheritance-III"><a href="#Inheritance-III" class="headerlink" title="Inheritance III"></a>Inheritance III</h2><h3 id="Subtype-Polymorphism"><a href="#Subtype-Polymorphism" class="headerlink" title="Subtype Polymorphism"></a>Subtype Polymorphism</h3><p>子类型多态性（Subtype Polymorphism）是面向对象编程中的一个重要特性，尤其在Java中广泛应用。以下是子类型多态性的作用和意思的详细解释。</p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>子类型多态性指的是在一个继承层次结构中，子类对象可以被视为其父类类型的对象。这意味着你可以使用父类引用指向子类的实例，从而在运行时根据对象的实际类型调用相应的方法。</p>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><ul>
<li><strong>灵活性</strong>：通过使用父类引用，可以在不修改代码的情况下扩展功能。只需添加新的子类并实现父类的方法，程序就可以处理新的子类对象。</li>
<li><strong>可替换性</strong>：子类型多态性使得可以在代码中使用任何子类实例，而不需要关注具体的子类类型。这使得代码更具通用性和可维护性。</li>
<li><strong>提高代码复用</strong>：父类中的方法可以被多个子类共享，减少了代码重复，提高了代码的复用性。</li>
<li><strong>实现接口和抽象类的多态性</strong>：在使用接口和抽象类时，可以实现更强大的多态性，允许不同的实现方式而不影响调用代码。</li>
</ul>
<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><p>下面是一个简单的示例，展示子类型多态性的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog对象被视为Animal类型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// Cat对象被视为Animal类型</span></span><br><span class="line"></span><br><span class="line">        myDog.sound(); <span class="comment">// 输出: Bark</span></span><br><span class="line">        myCat.sound(); <span class="comment">// 输出: Meow</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>myDog</code> 和 <code>myCat</code> 都是 <code>Animal</code> 类型的引用，但它们指向不同的子类对象。当调用 <code>sound()</code> 方法时，实际调用的是它们各自的实现。</p>
<p>我们现在用子类型多态性来搭建一个比较大小的代码：</p>
<p>先创建一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类以Dog来举例（难怪说狗是人类最好的朋友（bushi）)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; says:\&quot;Bark\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体比较大小（仍然以狗为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Maximizer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Maximizer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxDex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> items[maxDex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[]&#123;d1, d2, d3&#125;;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog)max(dogs);</span><br><span class="line">        maxDog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Inheritance-IV-iterators"><a href="#Inheritance-IV-iterators" class="headerlink" title="Inheritance IV iterators"></a><strong>Inheritance IV iterators</strong></h2><h3 id="Iterators-and-Iterables"><a href="#Iterators-and-Iterables" class="headerlink" title="Iterators and Iterables"></a>Iterators and Iterables</h3><p>在讲迭代器与可迭代对象之前，补充一下集合的简略代码(可以完成添加不重复的物品，以及查看集合是否包含这个元素)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>]; <span class="comment">// we can abjust the size/resize, just like we did in the array list </span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Adds an item to the set. (Ignores duplicates.) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contain</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (items[i].equal(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器与可迭代对象</strong>。这部分内容实际上就是 python 中迭代器的概念加上上文提到的用 Java 实现比较器的手段</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20191256.png" alt="屏幕截图 2024-10-09 191256"></p>
<p>我们可以从上面这张图发现新的遍历方法（java call this the enhanced for loop) ,我们将在揭开它的神秘面纱的过程中，了解迭代器与可迭代对象。</p>
<p>由于上面写了一个模拟集合的代码（不是java自带的），因此没有迭代器，所以如果使用enhanced loop,就会出现下面这种情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20193351.png" alt="屏幕截图 2024-10-09 193351"></p>
<p>迭代器相当于一个小巫师，它会检查ArraySet,一步步地遍历ArraySet逐一返回项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20204929.png" alt="屏幕截图 2024-10-09 204929"></p>
<p>搞错了（bushi）!?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20204457.png" alt="屏幕截图 2024-10-09 204457"></p>
<p>相关的接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此基础上我们实现了可迭代版本的 Arraysets，完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">       Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** returns an iterator (a.k.a. seer) into ME */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            wizPos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">            wizPos += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset.add(<span class="number">5</span>);</span><br><span class="line">        aset.add(<span class="number">23</span>);</span><br><span class="line">        aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iteration</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-methods"><a href="#Object-methods" class="headerlink" title="Object methods"></a>Object methods</h3><p>如上文所述，Java 中所有的类都是 Object 类的子类，也可以说 Object 是最顶端的 superclass，继承的方法如下：</p>
<ul>
<li><code>String toString()</code></li>
<li><code>boolean equals(Object obj)</code></li>
<li><code>Class &lt;?&gt; getClass()</code></li>
<li><code>int hashCode()</code></li>
<li><code>protected Objectclone()</code></li>
<li><code>protected void finalize()</code></li>
<li><code>void notify()</code></li>
<li><code>void notifyAll()</code></li>
<li><code>void wait()</code></li>
<li><code>void wait(long timeout)</code></li>
<li><code>void wait(long timeout, int nanos)</code></li>
</ul>
<p>这里专注理解前两个即可</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>相当于将某个对象字符串化的时候该怎么办？toString()解决的就是这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x += i.toString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在Java中，如果你试图将两个字符串加在一起，你实际上正在创建一个全新的字符串，打个比方，纸质书籍如果有错误或者需要加一些新内容，肯定要重新编辑，在印刷出来，这样一定会需要时间，实际上这与字符串不可变有关。</p>
<p>所以让我们来改进一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 借用Java自带的类</span></span><br><span class="line">    x.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x.append(i.toString());</span><br><span class="line">        x.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    x.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x.toString(); <span class="comment">// 原本类型是StringBuilder,需要转换成String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边还有一个问题，为什么”for(T i : this)”中用this,而不用items.</p>
<p>因为用items可能会有空值，而this刚刚好。</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h4><p>关于这个关键词，老面孔了，它有什么作用呢？</p>
<p>他会告诉你一个指向当前对象的引用。</p>
<p>与new关键词异曲同工，不过，他喊的不是新创建对象的地址，而是当前对象的地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20212635.png" alt="屏幕截图 2024-10-09 212635"></p>
<p>但有时我们会发现，size与this.size似乎是等价的；</p>
<p>这是为什么呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20212914.png" alt="屏幕截图 2024-10-09 212914"></p>
<p>当变量有同名变量时，不可以互转，因为Java不知道哪个是哪个。</p>
<p>this 还可以代替构造方法名，实现构造方法的调用,但它只能在构造方法中调用，且只能在第一句,不能与 <code>super()</code> 一起使用，除非是通过 <code>super()</code> 先调用父类构造方法，然后通过其他构造方法继续调用当前类的构造方法（隐含顺序决定：<code>super()</code> 总是先调用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>); <span class="comment">// 调用另一个构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">0</span>); <span class="comment">// 调用带两个参数的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用带一个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带两个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();       <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用带一个参数的构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); <span class="comment">// 直接调用带两个参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给出等价使用new方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用new创建对象并获取其字段值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">tempPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = tempPerson.name;</span><br><span class="line">        <span class="built_in">this</span>.age = tempPerson.age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用new创建对象并获取其字段值</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">tempPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = tempPerson.name;</span><br><span class="line">        <span class="built_in">this</span>.age = tempPerson.age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带一个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用带两个参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();       <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用带一个参数的构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); <span class="comment">// 直接调用带两个参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>注意，Java 中 <code>==</code> 在比较对象的时候实际上比较的是<strong>二者是否是同一个对象</strong>，即二者存储的地址是否相同。而这显然不符合特定情况下我们的要求，所以我们采取 <code>equals</code> 来<strong>重载我们的 <code>=</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArraySet otherArraySet) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上图我们又发现了“instanceof”这个奇怪的关键词，它是在判断o是否时ArraySet的一个实例,同时，我们又注意到otherAccaySet,这又是什么鬼东西？原来，如果前面的判断为true，他会为你执行一个额外的操作，即它将创建一个名为otherArraySet的新变量，类型为ArraySet.换句话说，它和o是一样的，他们包含相同的引用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214128.png" alt="屏幕截图 2024-10-09 214128"></p>
<p>话又说回来，如何判断两个数组大小相同呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214337.png" alt="屏幕截图 2024-10-09 214337"></p>
<p>大小相同，并且有互相的东西–“你有，我也有”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:/Users/28603/Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-09%20214543.png" alt="屏幕截图 2024-10-09 214543"></p>
<h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p>异常会导致正常的控制流停止。实际上，我们可以选择抛出自己的异常。在 Python 中，您可能已经看到过这种情况，使用 <code>raise</code> 关键字。在 Java 中，异常是对象，我们使用以下格式抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionObject</span>(parameter1, ...)</span><br></pre></td></tr></table></figure>

<p>一个典型例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Associates the specified value with the specified key in this map.</span><br><span class="line">   Throws an IllegalArgumentException if the key is null. */</span><br><span class="line">public void add(T x) &#123;</span><br><span class="line">    if (x == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;can&#x27;t add null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (contains(x)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这么做？以下是课本原文：</p>
<p>We get an Exception either way - why is this better?</p>
<ol>
<li>We have control of our code: we consciously decide at what point to stop the flow of our program</li>
<li>More useful Exception type and helpful error message for those using our code</li>
</ol>
<p>However, it would be better if the program doesn’t crash at all. There are different things we could do in this case. Here are some below:</p>
<p><strong>Approach 1</strong>: Don’t add <code>null</code> to the array if it is passed into <code>add</code></p>
<p><strong>Approach 2</strong>: Change the <code>contains</code> method to account for the case if <code>items[i] == null</code>.</p>
<p>Whatever you decide, it is important that users know what to expect. That is why documentation (such as comments about your methods) is very important</p>
<h2 id="Disjoint-Sets"><a href="#Disjoint-Sets" class="headerlink" title="Disjoint Sets"></a>Disjoint Sets</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>不相交集在名字上听起来像是数学上的<code>A∩B=0</code>,打一个日常生活的例子，比如世界地图，我们可以很清晰的看出国家之间的地理位置（国界是否接壤可以很清晰地看出来），或者，搭建桥梁连接两地，不相交集就是为了用代码表示诸如类似的情况。</p>
<p>为了判断是否连接和搭建连接，搭建不相交集需要以下两个操作：</p>
<ol>
<li><code>connect(x, y)</code>: Connects x and y</li>
<li><code>isConnected(x, y)</code>: Return true if x and y are connected</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** connects two items P and Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** checks to see if two items are connected */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不相交集的大致作用如下：</p>
<p>假设我们有四个元素如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro1_resized.png" alt="intro1_resized"></p>
<p>在调用<code>connect(A, B)</code>后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro2_resized.png" alt="intro2_resized"></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isConnected<span class="function"><span class="params">(A, B)</span> -&gt;</span> <span class="literal">true</span>;</span><br><span class="line">isConnected<span class="function"><span class="params">(A, C)</span> -&gt;</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>connect(A, D)</code> 后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10intro3_resized.png" alt="intro3_resized"></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isConnected<span class="function"><span class="params">(A, D)</span> -&gt;</span> <span class="literal">true</span></span><br><span class="line">isConnected<span class="function"><span class="params">(A, C)</span> -&gt;</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>从上述过程，我们可以发现<code>&#123;A&#125;, &#123;B&#125;, &#123;C&#125;, &#123;D&#125;</code>，通过一系列操作，变成了<code>&#123;A, B, D&#125;, &#123;C&#125;</code>,如何表示这个变化呢？我们可以用列表表示(<code>List&lt;Set&lt;Integger&gt;&gt;</code>): <code>[&#123;A, B, D&#125;, &#123;C&#125;]</code></p>
<h3 id="ListOfSetsDS"><a href="#ListOfSetsDS" class="headerlink" title="ListOfSetsDS"></a>ListOfSetsDS</h3><p><code>isConected</code>: 需要遍历列表中的所有集合来判断是否连接在一起。</p>
<ul>
<li><strong>时间复杂度</strong>：以最坏的情况来看（假设有N个集合），如果没有连接，且又在末尾，O(N)+O(N-1) &#x3D; O(N).</li>
</ul>
<p><code>connect</code>: 需要遍历所有集合，且代码十分复杂。</p>
<h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h3><p>我们进行第一次优化，将不相交集合用数组的方式来实现：</p>
<ul>
<li>The <strong>indices of the array</strong> represent the elements of our set.</li>
<li>The <strong>value at an index</strong> is the set number it belongs to.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/109.2.1.png" alt="9.2.1"></p>
<p><code>connect(x, y)</code>: 将其中一个位置的id修改为另一个的id即可</p>
<ul>
<li>时间复杂度：O(N)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(4).png" alt="image (4)"></p>
<p><code>isConnected(x, y)</code>: 查看两个位置的元素是否相同</p>
<ul>
<li>时间复杂度：O(1)</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* need to iterate through the array =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quick-union"><a href="#quick-union" class="headerlink" title="quick union"></a>quick union</h3><p>课本原话：</p>
<p>we assign each item the index of its parent. If an item has no parent, then it is a ‘root’ and we assign it a negative value.</p>
<ul>
<li>the nodes will be the items in our set,</li>
<li>each node only needs a reference to its parent rather than a direct reference to the face of the set, and</li>
<li>the top of each tree (we refer to this top as the “root” of the tree) will be the face of the set it represents.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(5).png" alt="image (5)"></p>
<p><code>connect(x, y)</code>: 假如我们要合并最左边的与中间的，我们要先找到两个对应的父链，再只需要将索引为3的元素改成0（为什么不是将索引为零的元素改成3之后会讨论）。</p>
<ul>
<li><p>时间复杂度:：O(N)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
分支任务1：为什么不是将索引为零的元素改成3</p>
</li>
</ul>
<p><code>isConnected(x, y)</code>:只要看所对应的父链是否相等。</p>
<ul>
<li>时间复杂度：O(N)</li>
</ul>
<p>为了完成quick union,还需要<code>find</code>寻找<code>item</code>所归属的根。</p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这串代码还会引发一个问题：会产生如下图丑陋的结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10worst.png" alt="worst"></p>
<p>为了避免这个问题，我们要进行如下优化：</p>
<h4 id="weight-quick-union"><a href="#weight-quick-union" class="headerlink" title="weight quick union"></a>weight quick union</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-21%20175018.png" alt="屏幕截图 2024-10-21 175018"></p>
<p>对于上述情况，我们是选择将T1连接到T2下还是将T2连接到T1下呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(6).png" alt="image (6)">当我们有两个不同大小的树，进行这个连接操作时，应该始终选择较小的树，并将其放在较大的树的下面（如上图)，这样合成的树的深度会比另一种情况矮，遍历一个分支的速度会快很多。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 分支任务1：为什么不是将索引为零的元素改成3</li>
</ul>
<p>一个巧妙的跟踪大小的方法，在父链所代表的元素上显示大小，也就是-1换成大小取负号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10initial.png" alt="initial"></p>
<p>调用<code>union(0,1)</code> 与 <code>union(2,3)</code>后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10union1.png" alt="union1"></p>
<h4 id="Weighted-Quick-Union-with-Path-Compression"><a href="#Weighted-Quick-Union-with-Path-Compression" class="headerlink" title="Weighted Quick Union with Path Compression"></a>Weighted Quick Union with Path Compression</h4><p>课本原文：</p>
<p>A clever optimization is to move the leaf up the tree so it becomes a direct child of the root. That way, the next time you call on that leaf, it will run much more quickly. An even more clever idea is that we could do the same thing to <em>every</em> node that is on the path from the leaf to the root. Specifically, when we call on an item, all of the nodes that were traversed upon going up the tree (to the root) are updated so that they are now connected directly to the root. This optimization is called <strong>path compression</strong>. Once you find an item, path compression will make finding it (and all the nodes on the path to the root) in the future faster.</p>
<p>大意：从底部的<code>item</code>往上爬，在此过程中，将路径上的<code>item</code>连接到它们的根。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10path_compression_before.png" alt="path_compression_before"></p>
<p>After we call on , all of the nodes we traversed to get to the root are updated so that they now connect directly to the root:<code>find(5)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10path_compression_after.png" alt="path_compression_after"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>N: number of elements in Disjoint Set</p>
<table>
<thead>
<tr>
<th>Implementation</th>
<th><code>isConnected</code></th>
<th><code>connect</code></th>
</tr>
</thead>
<tbody><tr>
<td>Quick Find</td>
<td>Θ(N)</td>
<td>Θ(1)</td>
</tr>
<tr>
<td>Quick Union</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td>Weighted Quick Union (WQU)</td>
<td>O(log N)</td>
<td>O(log N)</td>
</tr>
<tr>
<td>WQU with Path Compression</td>
<td>O(α(N))*</td>
<td>O(α(N))*</td>
</tr>
</tbody></table>
<h2 id="ADTS（Abstract-Data-Type）"><a href="#ADTS（Abstract-Data-Type）" class="headerlink" title="ADTS（Abstract Data Type）"></a>ADTS（Abstract Data Type）</h2><p>抽象数据结构(ADT)侧重于告诉你能做什么(What)，而不是具体告诉你怎么做(How)。</p>
<p>(Abstract data types (ADTs) are defined in terms of operations, not implementation.)</p>
<p>Some commonly used ADT’s are:</p>
<ul>
<li>Stacks: Structures that support last-in first-out retrieval of elements<ul>
<li><code>push(int x)</code>: puts x on the top of the stack</li>
<li><code>int pop()</code>: takes the element on the top of the stack</li>
</ul>
</li>
<li><strong>Lists</strong>: an ordered set of elements<ul>
<li><code>add(int i)</code>: adds an element</li>
<li><code>int get(int i)</code>: gets element at index i</li>
</ul>
</li>
<li><strong>Sets</strong>: an unordered set of unique elements (no repeats)<ul>
<li><code>add(int i)</code>: adds an element</li>
<li><code>contains(int i)</code>: returns a boolean for whether or not the set contains the value</li>
</ul>
</li>
<li><strong>Maps</strong>: set of key&#x2F;value pairs<ul>
<li><code>put(K key, V value)</code>: puts a key value pair into the map</li>
<li><code>V get(K key)</code>: gets the value corresponding to the key</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/1010%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20153010.png" alt="屏幕截图 2024-10-19 153010"></p>
<h3 id="BST（Binary-Search-Trees）"><a href="#BST（Binary-Search-Trees）" class="headerlink" title="BST（Binary Search Trees）"></a>BST（Binary Search Trees）</h3><h4 id="Derivation"><a href="#Derivation" class="headerlink" title="Derivation"></a>Derivation</h4><p>用链表一步步搭建二叉搜索树的雏形：</p>
<ol>
<li><p>首先，要保证是有序的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20154834.png" alt="屏幕截图 2024-10-19 154834"></p>
</li>
<li><p>为了提高效率，直接从中间开始</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20154904.png" alt="屏幕截图 2024-10-19 154904"></p>
</li>
<li><p>我们继续优化它，使它每一次都从指定区域的中间开始</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image.png" alt="image"></p>
</li>
</ol>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>在了解二叉搜索树之前，我们要先了解树的定义：</p>
<p>Trees are composed of:</p>
<ul>
<li>nodes </li>
<li>edges that connect those nodes. – 连接节点的线<ul>
<li><strong>Constraint</strong>: there is only one path between any two nodes.（两个节点只有唯一的路径）</li>
</ul>
</li>
</ul>
<p>In some trees, we select a <strong>root</strong> node which is a node that has no parents. </p>
<p>A tree also has <strong>leaves</strong>, which are nodes with no children.</p>
<p>进一步我们来了解Rooted Trees 和 Rooted Binary Trees</p>
<ul>
<li>Every node N except the root has exactly one parent,defined as the first node on the path from N to the root.</li>
<li>Unlike (most)real trees, the root is usually dispicted at the top of the tree.</li>
<li>A node with no child is called a leaf.</li>
</ul>
<p>In a rooted binery tree, every node has either 0, 1, or 2   </p>
<p>childreb(subtrees)</p>
<p>最后我们有<strong>二叉树</strong>和<strong>二叉搜索树</strong>的定义：</p>
<ul>
<li><p><strong>Binary Trees</strong>: in addition to the above requirements, also hold the binary property constraint. That is, each node has either 0, 1, or 2 children.</p>
</li>
<li><p>Binary Search Trees</p>
<p>: in addition to all of the above requirements, also hold the property that For every node X in the tree:</p>
<ul>
<li>Every key in the left subtree is less than X’s key.</li>
<li>Every key in the right subtree is greater than X’s key. <strong>Remember this property!! We will reference it a lot throughout the duration of this module and 61B.</strong></li>
</ul>
</li>
</ul>
<p><strong>Rule</strong>：No duplicate keys allowed.(没有重复)</p>
<p>Here is the BST class we will be using in this module:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST left, BST Right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><p>类比二分查找，当我们想要查找 BST 中的数据的时候，思路是同样的：</p>
<ul>
<li>和当前结点的值比大小，若是则返回</li>
<li>若是小于待查值，则往右拐</li>
<li>若是大于待查值，则往左拐</li>
</ul>
<p>如果树很茂密，那么树的高度 H &#x3D; log N，即意味着查找用时也是 log N.</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sk.equals(T.key))</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sk &lt; T.key)</span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>Search for key:</p>
<ul>
<li><p>If found, do nothing</p>
</li>
<li><p>If not found:</p>
<ul>
<li><p>Crete new node.</p>
</li>
<li><p>Set appropriate link</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key ik)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">  <span class="keyword">if</span> (ik ≺ T.key)</span><br><span class="line">    T.left = insert(T.left, ik);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ik ≻ T.key)</span><br><span class="line">    T.right = insert(T.right, ik);</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>3 Case:</p>
<ul>
<li>Deletion key has no children.</li>
<li>Deletion key has one children.</li>
<li>Deletion key has two children.</li>
</ul>
<p>对于第一种情况，直接让父链不再指向它，转身指向null.</p>
<p>对于第二种情况，让父节点把原本指向要删除的节点的指针指向它的子节点。</p>
<p>对于第三种情况，在要删除的节点下的子节点中找到一个合适的替换该要删除的节点。</p>
<h4 id="Map-VS-Set"><a href="#Map-VS-Set" class="headerlink" title="Map VS Set"></a>Map VS Set</h4><p>以下是课本原文：</p>
<p>We can use a BST to implement the <code>Set</code> ADT. If we use a BST, we can decrease the runtime of <code>contains</code> to log⁡(n)log(<em>n</em>) because of the BST property which enables us to use binary search!</p>
<p>We can also make a binary tree into a map by having each BST node hold <code>(key,value)</code> pairs instead of singular values. We will compare each element’s key in order to determine where to place it within our tree.</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        left = right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉搜索树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化根节点为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个新的值到二叉搜索树中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = insertRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地插入一个值</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right, value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索某个值是否存在于二叉搜索树中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地搜索某个值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历二叉搜索树（从小到大排序）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">()</span> &#123;</span><br><span class="line">        inorderRec(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地进行中序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderRec</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderRec(root.left);</span><br><span class="line">            System.out.print(root.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            inorderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = deleteRec(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地删除某个值</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deleteRec</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; root.value) &#123;</span><br><span class="line">            root.left = deleteRec(root.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value) &#123;</span><br><span class="line">            root.right = deleteRec(root.right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点只有一个子节点或者没有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该节点有两个子节点，找到中序后继（右子树的最小值）</span></span><br><span class="line">            root.value = minValue(root.right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除中序后继</span></span><br><span class="line">            <span class="comment">//root.right = deleteRec(root.right, root.value);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小值节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> root.value;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            minValue = root.left.value;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Balance-Trees"><a href="#Balance-Trees" class="headerlink" title="Balance Trees"></a>Balance Trees</h3><h4 id="Height-and-Depth"><a href="#Height-and-Depth" class="headerlink" title="Height and Depth"></a>Height and Depth</h4><p>高度与深度在BST中是十分重要的特征，决定BST的运行时间。</p>
<p>首先，高度与深度的关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(2).png" alt="image (2)"></p>
<p>其次，不同的插入方式可能造成同样的高度中存放不同数量的元素（如下图）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(1).png" alt="image (1)"></p>
<p>通过观察，我们发现左边的树十分茂密，而右边的树十分稀疏。这会造成如下的情形：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10image%20(3).png" alt="image (3)"></p>
<p>我们可以发现稀疏的树的平均深度比茂密的树的平均深度要大，这表明左边的运行时间会较大。</p>
<p>为了避免这种不平衡的情况（稀疏的情况），我们将讨论B-Tree</p>
<h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20202148.png" alt="屏幕截图 2024-10-19 202148"></h4><p>当子节点中元素等于4个，将会分裂，中间偏左的元素会到上一级，之前在它左边的和右边的分别当作它的子节点。</p>
<h4 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h4><p>B-Tree具有以下有用的不变性：</p>
<ul>
<li>All leaves must be the same distance from the source.</li>
<li>A non-leaf node with 𝑘 items must have exactly 𝑘+1 children.</li>
</ul>
<p>In tandem, these invariants cause the tree to always be bushy.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20203629.png" alt="屏幕截图 2024-10-19 203629"></p>
<p>节点可以存放元素的个数等于这棵树的高度</p>
<h4 id="Runtime-for-contains"><a href="#Runtime-for-contains" class="headerlink" title="Runtime for contains"></a>Runtime for <code>contains</code></h4><p>In the worst case, we have to examine up to L<em>L</em> items per node. We know that height is logarithmic, so the runtime of <code>contains</code> is bounded by O(Llog⁡N)<em>O</em>(<em>L</em>log<em>N</em>). Since L<em>L</em> is a constant, we can drop the multiplicative factor, resulting in a runtime of O(log⁡N).</p>
<h4 id="Runtime-for-add"><a href="#Runtime-for-add" class="headerlink" title="Runtime for add"></a>Runtime for <code>add</code></h4><p>A similar analysis can be done for <code>add</code>, except we have to consider the case in which we must split a leaf node. Since the height of the tree is O(log⁡N)<em>O</em>(log<em>N</em>), at worst, we do log⁡Nlog<em>N</em> split operations (cascading from the leaf to the root). This simply adds an additive factor of log⁡Nlog<em>N</em> to our runtime, which still results in an overall runtime of O(log⁡N).</p>
<h2 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red Black Trees"></a>Red Black Trees</h2><p>即使B-Tree十分平衡均匀，但实际跟踪要分裂的节点是十分复杂的。因此，我们需要另辟蹊径创造一个全新的B-Tree.</p>
<h3 id="Rotating-Tree"><a href="#Rotating-Tree" class="headerlink" title="Rotating Tree"></a>Rotating Tree</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20164235.png" alt="屏幕截图 2024-10-24 164235"></p>
<p>对于上面这张图，即使树的结构千姿百态，但所包含的元素却是相同的。为了获得矮小的树，我们引入旋转的方法（如下图所示）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20164720.png" alt="屏幕截图 2024-10-24 164720"></p>
<p>我们想让<code>G</code>向左旋转，过程可以看作是<code>G</code>与与它相连的右节点<code>P</code>暂时融合，然后把想要旋转的节点发射到左边，并且连接一两条分支。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>return x</code>是为了得知<code>parent node</code>指向哪个节点！</p>
<h3 id="Create-LLRB-Trees"><a href="#Create-LLRB-Trees" class="headerlink" title="Create LLRB Trees"></a>Create LLRB Trees</h3><p>红黑树有几个重要的性质：</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL节点）是黑色。</li>
<li>如果一个节点是红色，则它的两个子节点必须是黑色（即不允许有两个连续的红色节点）。</li>
<li>从任何节点到其每个叶子节点的所有路径都必须包含相同数量的黑色节点。</li>
</ul>
<p>以2-3树为例</p>
<p>对于一个有多个项目的节点，我们可以利用之前创造链表的思路设置一个哨兵：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20173652.png" alt="屏幕截图 2024-10-24 173652"></p>
<p>但这个节点有点浪费，我们有更好的处理方式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20173818.png" alt="屏幕截图 2024-10-24 173818"></p>
<p><code>We show that a link is a glue link by making it red. Normal links are black.</code>因此 我们称它为 <strong>left-leaning red-black trees (LLRB)</strong>. </p>
<p><strong>关于LLRB特点</strong></p>
<p>课本原文：</p>
<ul>
<li>1-1 correspondence with 2-3 trees.</li>
<li>No node has 2 red links.</li>
<li>There are no red right-links.</li>
<li>Every path from root to leaf has the same number of black links (because 2-3 trees have the same number of links to every leaf).</li>
<li>Height is no more than 2x height + 1 of the corresponding 2-3 tree. </li>
<li>The height of a red-black tree is proportional to the log of the number of entries.</li>
</ul>
<h4 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h4><p>左倾红黑树，说明了红线是在左边的.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181208.png" alt="屏幕截图 2024-10-24 181208"></p>
<p>同一个节点的同一侧不能有两条红色链接:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181223.png" alt="屏幕截图 2024-10-24 181223"></p>
<p>如何处理节点的分裂：转换那个分裂的节点所连接的线的性质（在图示中，就是改变线的颜色），更准确地说，分裂的主要操作是将<strong>中间节点上提</strong>，并且将子节点和中间节点的红色链接进行调整，可能还需要旋转：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20181234.png" alt="屏幕截图 2024-10-24 181234"></p>
<p>课本对次的总结</p>
<ul>
<li>When inserting: Use a <strong>red link</strong>. Insert in the same way as inserting into a BST.</li>
<li>If there is a right-leaning “3-node”, we have a <strong>Left Leaning Violation</strong>.<ul>
<li><strong>Rotate left</strong> the appropriate node to fix.</li>
</ul>
</li>
<li>If there are two consecutive left links, we have an <strong>Incorrect 4 Node Violation</strong>.<ul>
<li><strong>Rotate right</strong> the appropriate node to fix.</li>
</ul>
</li>
<li>If there are any nodes with two red children, we have a <strong>Temporary 4 Node</strong>.<ul>
<li><strong>Color flip</strong> the node to emulate the split operation.</li>
</ul>
</li>
</ul>
<h3 id="Runtime-Analyse"><a href="#Runtime-Analyse" class="headerlink" title="Runtime Analyse"></a>Runtime Analyse</h3><p>因为红黑左倾树与B-Tree一一对应（<strong>每一个</strong> 2-3树都可以唯一地表示为一棵左倾红黑树。反之亦然）,所以时间复杂度也是 <em>l<strong>o</strong>g</em>(<em>N</em>) 。</p>
<p>Here’s the abstracted code for insertion into a LLRB:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, Key key, Value val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; h.right = put(h.right, key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span>              &#123; h.val   = val;                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><h3 id="Introduction-to-Hashing-Data-indexed-Arrays"><a href="#Introduction-to-Hashing-Data-indexed-Arrays" class="headerlink" title="Introduction to Hashing: Data indexed Arrays"></a>Introduction to Hashing: Data indexed Arrays</h3><p>目前，我们搭建了许多数据结构来存放数据，但我们不是很满意，一是因为时间复杂度不是<code>O(1)</code>, 二是因为之前的数据结构都是需要可比较的数据的。所以，我们要搭建一个可以容纳所有事物以及时间复杂度完美的数据结构。</p>
<p>说到时间复杂度为<code>O(1)</code>,就会想到数组，无论是<code>add()</code>还是<code>contain()</code>，时间复杂度都为常数时间。</p>
<p>搭建一个容纳所有数字的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这串代码有两大致命缺点：</p>
<ul>
<li>太浪费内存空间：如果只插入一两个数据，剩下的空间无处可用。</li>
<li>只适用于整数类型</li>
</ul>
<h3 id="Hash-Code"><a href="#Hash-Code" class="headerlink" title="Hash Code"></a>Hash Code</h3><p>Hash可以存储所有类型，但数组所含类型要一致，我们只能忍痛割爱，选择整数了，为了把字符转换为数字，我们专门写一个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-Inefficiency-in-Hash-Codes"><a href="#Memory-Inefficiency-in-Hash-Codes" class="headerlink" title="Memory Inefficiency in Hash Codes"></a>Memory Inefficiency in Hash Codes</h3><p>我们可以使用一个单独存放每个哈希值的数组。也就是说，数组中的每个索引都代表一个唯一的哈希值。如果我们的指标很小并且接近于零，这个方法很有效。但是我们想要存放hash值范围可能只有很小的一部分，我们也可能需要一个十分长的数组。</p>
<p>相反，我们将稍微修改我们的索引策略。假设我们只想支持长度为10的数组，以避免分配过多的内存。我们如何将一个可能是数百万或数十亿的数字转换为0到9（包括0到9）之间的值？</p>
<h3 id="Wrapping"><a href="#Wrapping" class="headerlink" title="Wrapping!"></a>Wrapping!</h3><p>我们可以使用<code>floorMod()</code>来实现我们想要的数组大小，即使超出数组大小，这个函数也可以将他转换为我们数组允许的大小。</p>
<p>原理：floorMod函数将在正确计算负整数的情况下执行取模操作：<code>Math.floorMod(-3, 10) = 7 --------&gt; -3 = -1 * 10 + 7</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floorMod(key.hashCode(), array.length)</span><br></pre></td></tr></table></figure>

<p>这就像规定了水桶的数量，将数据放在指定的水桶，我们预先只规定了桶的数量与容量极限，刚开始都只是空桶，我们按游戏规则往里面放东西，放多少东西是我们自己决定的（放多少有多少），相比之前数组一开始就把容量固定好了，更加节约空间，但如果每个桶都到达极限，我们需要再增添一些桶。但这个极限怎么规定呢？我们会定义一个 load factor （负载因子）（N&#x2F;M，其中N是表中元素的数量，M是桶的数量），超过某个常数就会添加桶的数目。</p>
<p>字符&#x2F;数字等要存放的数据的默认哈希值是它们的地址值（每一次运行都是随机的）.</p>
<h3 id="Comparing-Data-Structure-Run-Times"><a href="#Comparing-Data-Structure-Run-Times" class="headerlink" title="Comparing Data Structure Run Times!"></a>Comparing Data Structure Run Times!</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">contains(x)</th>
<th align="left">add(x)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bushy BSTs</td>
<td align="left">Θ(log N)</td>
<td align="left">Θ(log N)</td>
</tr>
<tr>
<td align="left">Separate Chaining Hash Table with NO resizing</td>
<td align="left">Θ(N)</td>
<td align="left">Θ(N)</td>
</tr>
<tr>
<td align="left">Separate Chaining Hash Table with resizing</td>
<td align="left">Θ(1)</td>
<td align="left">Θ(1)</td>
</tr>
</tbody></table>
<p><code>floorMod()</code>不需要在<code>hashCode()</code>中执行，可以放在hashtable中，<code>hashCode()</code>返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不使用默认哈希值，在查找对应的元素，由于地址是随机的，查找元素的地址也是随机的，两个元素取模可能结果不一致。要保证<code>equal()</code>和<code>contain()</code>哈希值规定一致。</p>
<p>原话：<strong>Basic rule (also definition of deterministic property of a valid hashcode):</strong> If two objects are equal, they <strong>must</strong> have the same hash code so the hash table can find it.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   ...  <span class="keyword">return</span> <span class="built_in">this</span>.num == otherCn.num; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutable-vs-Immutable-Types"><a href="#Mutable-vs-Immutable-Types" class="headerlink" title="Mutable vs. Immutable Types"></a>Mutable vs. Immutable Types</h3><p>可变性：可以外部改变</p>
<p>不变性：不可改变</p>
<ul>
<li><p><code>final</code> ：作为修饰词定义变量不可改变</p>
</li>
<li><p><code>private</code>: 作为修饰词定义变量不可改变（限制访问）</p>
<p>注意：对于数组里的元素不起效，上面的两个只能保证定义的那个变量不可改变，保证数组指向内存仍然是之前的，内部的元素不在管辖之内</p>
<p>为了让数组彻底不可改变，可以定义一个类进行封装。</p>
</li>
</ul>
<h2 id="Heaps-and-Priority-Quenes"><a href="#Heaps-and-Priority-Quenes" class="headerlink" title="Heaps and Priority Quenes"></a>Heaps and Priority Quenes</h2><h3 id="Priority-Quenes"><a href="#Priority-Quenes" class="headerlink" title="Priority Quenes"></a>Priority Quenes</h3><p>优先队列作为一个数据结构，大致结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** (Min) Priority Queue: Allowing tracking and removal of </span></span><br><span class="line"><span class="comment">  * the smallest item in a priority queue. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Priority Queue is an Abstract Data Type that optimizes for handling minimum or maximum elements.</li>
<li>There can be space&#x2F;memory benefits to using this specialized data structure.</li>
<li>Implementations for ADTs that we currently know don’t give us efficient runtimes for PQ operations.<ul>
<li>A binary search tree is the most efficient among the other structures</li>
</ul>
</li>
</ul>
<h3 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h3><p>特性：</p>
<ul>
<li>Min-heap: 节点始终小3于等于它的两个子节点</li>
<li>Complete: 节点尽可能地靠左。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20153855.png" alt="屏幕截图 2024-10-29 153855"></p>
<p>一些操作：</p>
<ul>
<li>add: 暂时添加到底部，如果child &lt; parent，则交换节点</li>
<li>getSmallest：根节点</li>
<li>removeSmalleat；让底部的节点代替根节点，如果parent  &gt; child，则交换节点</li>
</ul>
<p>实现方式：</p>
<ul>
<li><p><strong>Tree1A</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1A</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1A left;</span><br><span class="line">  Tree1A middle;</span><br><span class="line">  Tree1A right;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160422.png" alt="屏幕截图 2024-10-29 160422"></p>
</li>
<li><p><strong>Tree1B</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1B</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1B[] children;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160622.png" alt="屏幕截图 2024-10-29 160622"></p>
</li>
<li><p><strong>TreeC</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1C favoredChild;</span><br><span class="line">  Tree1C sibling;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20160756.png" alt="屏幕截图 2024-10-29 160756"></p>
</li>
</ul>
<p>搭建代码：</p>
<p>效仿<code>Disjoint Set</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  <span class="type">int</span>[] parents;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20161421.png" alt="屏幕截图 2024-10-29 161421"></p>
<p>但我们发现<code>parents</code>似乎是多余的，因为keys与树的结构一一对应（都是左边节点序号再右边节点序号再左边节点的左子节点…以此往复，对应的数组也只是同样节点的子节点序号一致）</p>
<p>所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeC</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20162015.png" alt="屏幕截图 2024-10-29 162015"></p>
<p><strong>swim</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys[parent(k)] ≻ keys[k]) &#123;</span><br><span class="line">       swap(k, parent(k));</span><br><span class="line">       swim(parent(k));              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应：</p>
<ul>
<li><code>leftChild(k)</code>&#x3D; k∗2 +1</li>
<li><code>rightChild(k)</code>&#x3D; k∗2+2</li>
<li><code>parent(k)</code>&#x3D; （k-1）&#x2F;2</li>
</ul>
<h3 id="Comparing-to-alternative-implementations"><a href="#Comparing-to-alternative-implementations" class="headerlink" title="Comparing to alternative implementations"></a>Comparing to alternative implementations</h3><table>
<thead>
<tr>
<th align="left">Methods</th>
<th align="left">Ordered Array</th>
<th align="left">Bushy BST</th>
<th align="left">Hash Table</th>
<th align="left">Heap</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>add</code></td>
<td align="left">Θ(N)Θ(<em>N</em>)</td>
<td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td>
<td align="left">Θ(1)Θ(1)</td>
<td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td>
</tr>
<tr>
<td align="left"><code>getSmallest</code></td>
<td align="left">Θ(1)Θ(1)</td>
<td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td>
<td align="left">Θ(N)Θ(<em>N</em>)</td>
<td align="left">Θ(1)Θ(1)</td>
</tr>
<tr>
<td align="left"><code>removeSmallest</code></td>
<td align="left">Θ(N)Θ(<em>N</em>)</td>
<td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td>
<td align="left">Θ(N)Θ(<em>N</em>)</td>
<td align="left">Θ(logN)Θ(<em>l<strong>o</strong>g**N</em>)</td>
</tr>
</tbody></table>
<h3 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a><strong>完整代码如下：</strong></h3><p>以最小堆为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heaps</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heaps</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        heap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[i].compareTo(heap[parent(i)]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(i, parent(i));</span><br><span class="line">            i = parent(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == heap.length - <span class="number">1</span>) &#123; <span class="comment">// 修改了越界检查</span></span><br><span class="line">            <span class="built_in">this</span>.resize(heap.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[size] = t;</span><br><span class="line">        swim(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        T[] newHeap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[newCapacity + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(heap, <span class="number">0</span>, newHeap, <span class="number">0</span>, size);</span><br><span class="line">        heap = newHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(heap[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left(k) &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left(k);</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; size &amp;&amp; heap[j + <span class="number">1</span>].compareTo(heap[j]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap[k].compareTo(heap[j]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        sink(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Tree-Traversals-and-Graphs"><a href="#Tree-Traversals-and-Graphs" class="headerlink" title="Tree Traversals and Graphs"></a>Tree Traversals and Graphs</h2><h3 id="Tree-Traversal"><a href="#Tree-Traversal" class="headerlink" title="Tree Traversal"></a>Tree Traversal</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-30%20215713.png" alt="屏幕截图 2024-10-30 215713"></p>
<ul>
<li><p>Level Order Traversal:一层层从左向右遍历 （D B F A C E G）</p>
</li>
<li><p>Pre-order Traversal: 优先结点最先（D B A C  F E G）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    print(x.key)</span><br><span class="line">    preOrder(x.left)</span><br><span class="line">    preOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>In-order Traversal: 优先结点其次（A B C D E F G）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    inOrder(x.left)</span><br><span class="line">    print(x.key)</span><br><span class="line">    inOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Post-order Traversal：优先结点最后（A C B E G F D）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    postOrder(x.left)</span><br><span class="line">    postOrder(x.right)</span><br><span class="line">    print(x.key)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表-树-图"><a href="#表-树-图" class="headerlink" title="表&amp;&amp;树&amp;&amp;图"></a><strong>表&amp;&amp;树&amp;&amp;图</strong></h3><p>表：</p>
<ul>
<li>结点之间路径唯一</li>
<li>子结点唯一</li>
</ul>
<p>树：</p>
<ul>
<li>结点之间路径唯一</li>
<li>子节点不唯一</li>
</ul>
<p>图：</p>
<ul>
<li>结点之间路径不唯一</li>
<li>子节点不唯一</li>
</ul>
<h3 id="Simple-Graphs-VS-multigraphs"><a href="#Simple-Graphs-VS-multigraphs" class="headerlink" title="Simple Graphs VS multigraphs"></a>Simple Graphs <strong>VS</strong> <em>multigraphs</em></h3><p>复杂图相比简单图会有自环（一个节点到自身的边）和重边（两个节点之间的多条边），甚至有更复杂的结构。</p>
<h2 id="Graph-Traversals-and-implementations"><a href="#Graph-Traversals-and-implementations" class="headerlink" title="Graph Traversals and implementations"></a>Graph Traversals and implementations</h2><h2 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h2><h2 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h2><h2 id="Prefix-Operations-and-Tries"><a href="#Prefix-Operations-and-Tries" class="headerlink" title="Prefix Operations and Tries"></a>Prefix Operations and Tries</h2><h2 id="Sorting-–-排序方法"><a href="#Sorting-–-排序方法" class="headerlink" title="Sorting – 排序方法"></a>Sorting – 排序方法</h2><p>这节的任务列表如下：</p>
<ul>
<li><input disabled="" type="checkbox"> Section Sort</li>
<li><input disabled="" type="checkbox"> Heap Sort</li>
</ul>
<h3 id="Selection-Sort-–-选择排序"><a href="#Selection-Sort-–-选择排序" class="headerlink" title="Selection Sort – 选择排序"></a>Selection Sort – 选择排序</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-18%20201012.png" alt="屏幕截图 2024-10-18 201012"></p>
<p><em><strong>选择排序有两种实现方式：</strong></em></p>
<ol>
<li>找到最小的元素，把它放在最左边，然后在剩余的元素中重复这个操作。</li>
<li>找到最大的元素，把它放在最右边，然后在剩余的元素中重复这个操作。</li>
</ol>
<h4 id="Section-Runtime"><a href="#Section-Runtime" class="headerlink" title="Section Runtime"></a>Section Runtime</h4><p>   <strong>时间复杂度：O(N^2);</strong></p>
<p>   选择排序每次操作都在找最小的值，还记得堆(heap)和优先队列(priority)吗？堆十分擅                      长告诉我们最小的元素。</p>
<h3 id="Heap-Sort-–-堆排序"><a href="#Heap-Sort-–-堆排序" class="headerlink" title="Heap Sort – 堆排序"></a>Heap Sort – 堆排序</h3><h4 id="Naive-heap-sort"><a href="#Naive-heap-sort" class="headerlink" title="Naive heap sort"></a>Naive heap sort</h4><ul>
<li><p>Insert all items into a max heap, and discard input array. Create output array.</p>
</li>
<li><p>Repeated N times:</p>
<ul>
<li><p>Delete largest item from the max heap.</p>
</li>
<li><p>Put largest item at the end of the unused part of the output array.</p>
<p> 这一步就是将堆的最大值放在大小为size的数组最后可放的位置，然后移除最大值，直到第一个元素为最小。</p>
</li>
</ul>
<p>这边有一个问题：为什么不用最小堆，这个问题我们先不讨论，先把它放在<strong>分支任务</strong>里。</p>
<p>分支任务如下：</p>
<ul>
<li><input disabled="" type="checkbox"> 堆排序为什么用最大堆而不是最小堆</li>
</ul>
</li>
</ul>
<p>总运行时间有两个步骤：</p>
<ul>
<li><p>堆排列的时间：O(N logN).</p>
</li>
<li><p>删除元素的总时间：O(N(需要删除的元素个数) * logN(每次删除的时间)) &#x3D; O(N logN).</p>
<p> 最后结合两个的时间，得到的<strong>时间复杂度</strong>为O(N logN).</p>
</li>
</ul>
<p>我们再来看看空间复杂度（内存使用情况）：创建了一个大小为N的数组来存放堆，又创建一个大小为N的数组来存放排好序的元素。</p>
<p>所以，内存使用情况为O(N).</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Section Sort</li>
</ul>
<h4 id="Heapification"><a href="#Heapification" class="headerlink" title="Heapification"></a>Heapification</h4><p>我们不想创建额外的数组，可以将数组堆化，但这个堆并不是有效的最大堆。</p>
<ul>
<li>Bottom-up heapify input array:<ul>
<li>Sink nodes in reverse level order: sink(k)</li>
<li>After sinking, guarantee that rooted at position k is a heap.</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterOfWinter/markdown_pic@main/2024/10%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-18%20210729.png" alt="屏幕截图 2024-10-18 210729"></p>
<p>这一步是从堆的底部开始，当子节点比节点大就交换位置。</p>
<p>现在让我们来解决为什么使用最大堆而不是最小堆（视频位置Lecture 24 –  44：10）：</p>
<p>如果堆（heap）正在消耗元素以至于它的后面的元素开始变得未使用，而输出数组正在从后面填充元素，以至于它们未被使用，它们处于一种动态平衡的状况，这种情况下不需要创建一个新数组。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 堆排序为什么用最大堆而不是最小堆</li>
</ul>
<h4 id="Heapsort-Runtime"><a href="#Heapsort-Runtime" class="headerlink" title="Heapsort Runtime"></a>Heapsort Runtime</h4><p>总运行时间分为两个步骤：</p>
<ul>
<li>自底而上的堆化过程的时间：最坏的情况下，我们要堆化(堆化时间为logN)所有元素(N个)，时间为O(N logN)</li>
<li>删除元素：O(N(元素个数) * (删除一个元素的时间)logN) &#x3D; O(N logN)</li>
<li><input checked="" disabled="" type="checkbox"> Heap Sort</li>
</ul>
<h3 id="Mergesort"><a href="#Mergesort" class="headerlink" title="Mergesort"></a>Mergesort</h3><p>merge —- 合并 —–&gt; 分组排序<br>对于一大堆无序的数据，一次性整理有序是十分困难的，时间复杂度还为O($N^2$),但我们可以将这一大堆数据一分为二在进行排序，虽然这样单独一个小组的时间复杂度仍然是O($N^2$)（比未分组之前的O($N^2$)的快），但由于合并时时间复杂度为O(1),所以已经快很多了。我们已经执行过一次一分为二了，为什么不做到底，直到不能再分，此时我们甚至不需要再使用选择排序了，因为一个数据就是有序的。<br><strong>归并排序</strong>的本质：</p>
<ul>
<li>如果列表大小为 1，则返回。否则：</li>
<li>对左半部分进行合并排序</li>
<li>合并排序右半部分</li>
<li>合并结果<br><strong>运行时间：</strong> $Nlog_{2}{X}$<br>具体计算过程：<br>$$<br>C(N) &#x3D; \left{\begin{matrix}<br>      1&amp;  &amp;N&#x3D;1 \<br>      2C(N&#x2F;2)+N&amp;  &amp;N&gt;&#x3D;2<br> \end{matrix}\right.</li>
</ul>
<p>$$<br>具体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void mergeSort(int[] array, int left, int right) &#123;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            mergeSort(array, left, mid);</span><br><span class="line">            mergeSort(array, mid + 1, right);</span><br><span class="line">            merge(array, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void merge(int[] array, int left, int mid, int right) &#123;</span><br><span class="line">        int n1 = mid - left + 1;</span><br><span class="line">        int n2 = right - mid;</span><br><span class="line"></span><br><span class="line">        int[] L = new int[n1];</span><br><span class="line">        int[] R = new int[n2];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n1; i++)</span><br><span class="line">            L[i] = array[left + i];</span><br><span class="line">        for (int j = 0; j &lt; n2; j++)</span><br><span class="line">            R[j] = array[mid + 1 + j];</span><br><span class="line"></span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int k = left;</span><br><span class="line">        while (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            if (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                array[k] = L[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[k] = R[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt; n1) &#123;</span><br><span class="line">            array[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (j &lt; n2) &#123;</span><br><span class="line">            array[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;12, 11, 13, 5, 6, 7&#125;;</span><br><span class="line">        mergeSort(array, 0, array.length - 1);</span><br><span class="line">        for (int num : array) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><h3 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://waterofwinter.github.io/water.github.io">water</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://waterofwinter.github.io/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/">https://waterofwinter.github.io/water.github.io/2024/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://waterofwinter.github.io/water.github.io" target="_blank">Water's study corner</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/water.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BAComputer/">计算机Computer</a></div><div class="post_share"><div class="social-share" data-image="/water.github.io/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241017164223.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/water.github.io/2024/10/10/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0CSAPP%E8%BF%99%E6%A1%A3%E4%BA%8B/" title="关于学习CSAPP这档事"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于学习CSAPP这档事</div></div></a></div><div class="next-post pull-right"><a href="/water.github.io/2024/10/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%97%85%E7%A8%8B/" title="线性代数的旅程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线性代数的旅程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/water.github.io/2024/10/07/CS50-%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/" title="CS50--梦开始的地方"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="title">CS50--梦开始的地方</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/water.github.io/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241017164223.jpg" onerror="this.onerror=null;this.src='/water.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">water</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/water.github.io/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/water.github.io/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/water.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WaterOfWinter"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/WaterOfWinter" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2860366719@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to water's study corner</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%85%E7%A8%8B"><span class="toc-text">*数据结构的旅程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java"><span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Workflow"><span class="toc-text">Java Workflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-text">Command Line Arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Types"><span class="toc-text">Reference Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Golden-Rule-of-Equals-GRoE"><span class="toc-text">The Golden Rule of Equals (GRoE)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Instantiation"><span class="toc-text">Object Instantiation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#New"><span class="toc-text">New</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Members"><span class="toc-text">Java Members</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#variable"><span class="toc-text">variable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Methods"><span class="toc-text">Methods</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-in-Java"><span class="toc-text">Constructors in Java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB%EF%BC%9A"><span class="toc-text">类别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-text">构造函数与实例化的关系：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B0%81%E8%A3%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">构造函数与封装的关系:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">实例化与封装数据的关系:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Public-Private-Protected-default"><span class="toc-text">Public&amp;&amp;Private&amp;&amp;Protected&amp;&amp;default</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntList"><span class="toc-text">IntList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLList"><span class="toc-text">SLList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#naked-recursive"><span class="toc-text">naked recursive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start"><span class="toc-text">Start</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DLList"><span class="toc-text">DLList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alist"><span class="toc-text">Alist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance-I"><span class="toc-text">Inheritance I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Override-default-interface"><span class="toc-text">Override &amp;&amp; default &amp;&amp; interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-method-selection"><span class="toc-text">dynamic method selection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Superclass-Subclass"><span class="toc-text">Superclass &amp;&amp; Subclass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance-II"><span class="toc-text">Inheritance II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extend"><span class="toc-text">Extend</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-extends"><span class="toc-text">1. extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-implements"><span class="toc-text">2. implements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 关系与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Super"><span class="toc-text">Super</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super-%E5%92%8C-this-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">super 和 this 的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Encapsulation"><span class="toc-text">Encapsulation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E5%B0%81%E8%A3%85%EF%BC%88Encapsulation%EF%BC%89"><span class="toc-text">1. Java封装（Encapsulation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85"><span class="toc-text">2. 模块封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3. 封装与模块封装的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Higher-Order-Functions-in-Java"><span class="toc-text">Higher Order Functions in Java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance-III"><span class="toc-text">Inheritance III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Subtype-Polymorphism"><span class="toc-text">Subtype Polymorphism</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8"><span class="toc-text">2. 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance-IV-iterators"><span class="toc-text">Inheritance IV iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterators-and-Iterables"><span class="toc-text">Iterators and Iterables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-methods"><span class="toc-text">Object methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exceptions"><span class="toc-text">Exceptions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Disjoint-Sets"><span class="toc-text">Disjoint Sets</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-1"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListOfSetsDS"><span class="toc-text">ListOfSetsDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-Find"><span class="toc-text">Quick Find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quick-union"><span class="toc-text">quick union</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#weight-quick-union"><span class="toc-text">weight quick union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Weighted-Quick-Union-with-Path-Compression"><span class="toc-text">Weighted Quick Union with Path Compression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary"><span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADTS%EF%BC%88Abstract-Data-Type%EF%BC%89"><span class="toc-text">ADTS（Abstract Data Type）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%EF%BC%88Binary-Search-Trees%EF%BC%89"><span class="toc-text">BST（Binary Search Trees）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Derivation"><span class="toc-text">Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition"><span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Search"><span class="toc-text">Search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Insert"><span class="toc-text">Insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete"><span class="toc-text">delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-VS-Set"><span class="toc-text">Map VS Set</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balance-Trees"><span class="toc-text">Balance Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Height-and-Depth"><span class="toc-text">Height and Depth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Trees"><span class="toc-text">B-Trees</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Invariants"><span class="toc-text">Invariants</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime-for-contains"><span class="toc-text">Runtime for contains</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime-for-add"><span class="toc-text">Runtime for add</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Red-Black-Trees"><span class="toc-text">Red Black Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rotating-Tree"><span class="toc-text">Rotating Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-LLRB-Trees"><span class="toc-text">Create LLRB Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Insert-1"><span class="toc-text">Insert</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-Analyse"><span class="toc-text">Runtime Analyse</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashing"><span class="toc-text">Hashing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-to-Hashing-Data-indexed-Arrays"><span class="toc-text">Introduction to Hashing: Data indexed Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Code"><span class="toc-text">Hash Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Inefficiency-in-Hash-Codes"><span class="toc-text">Memory Inefficiency in Hash Codes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wrapping"><span class="toc-text">Wrapping!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparing-Data-Structure-Run-Times"><span class="toc-text">Comparing Data Structure Run Times!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutable-vs-Immutable-Types"><span class="toc-text">Mutable vs. Immutable Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heaps-and-Priority-Quenes"><span class="toc-text">Heaps and Priority Quenes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Priority-Quenes"><span class="toc-text">Priority Quenes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heaps"><span class="toc-text">Heaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparing-to-alternative-implementations"><span class="toc-text">Comparing to alternative implementations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">完整代码如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tree-Traversals-and-Graphs"><span class="toc-text">Tree Traversals and Graphs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-Traversal"><span class="toc-text">Tree Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8-%E6%A0%91-%E5%9B%BE"><span class="toc-text">表&amp;&amp;树&amp;&amp;图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Graphs-VS-multigraphs"><span class="toc-text">Simple Graphs VS multigraphs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph-Traversals-and-implementations"><span class="toc-text">Graph Traversals and implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shortest-Paths"><span class="toc-text">Shortest Paths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Spanning-Trees"><span class="toc-text">Minimum Spanning Trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prefix-Operations-and-Tries"><span class="toc-text">Prefix Operations and Tries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting-%E2%80%93-%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-text">Sorting – 排序方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Selection-Sort-%E2%80%93-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">Selection Sort – 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Section-Runtime"><span class="toc-text">Section Runtime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Sort-%E2%80%93-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">Heap Sort – 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Naive-heap-sort"><span class="toc-text">Naive heap sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heapification"><span class="toc-text">Heapification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heapsort-Runtime"><span class="toc-text">Heapsort Runtime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mergesort"><span class="toc-text">Mergesort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insertion-Sort"><span class="toc-text">Insertion Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quicksort"><span class="toc-text">Quicksort</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/water.github.io/images/103008653_p0_master1200.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 By water</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/water.github.io/js/utils.js?v=4.13.0"></script><script src="/water.github.io/js/main.js?v=4.13.0"></script><script src="/water.github.io/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/water.github.io/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>